/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package icms;

import javax.swing.JOptionPane;

/**
 *
 * @author Manishankar
 */
public class ContextBugs extends javax.swing.JFrame {

    
    CommonParameters cp = new CommonParameters ();
    DatabaseAccess da = new DatabaseAccess ();
    InvestigatingBugproneness ib = new InvestigatingBugproneness ();
    ChangeAnalysis ca = new ChangeAnalysis ();
    VisualizeCode vc = new VisualizeCode ();    
    ConsistentAndInconsistentChangePatterns cpattern = new ConsistentAndInconsistentChangePatterns();
    
    int [][] potentialpairs = new int [50000][3];
    int [] potentialpairsrevisions = new int [50000];
    int paircount = 0;
    
    
    
    /**
     * Creates new form ContextBugs
     */
    public ContextBugs() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton1.setText("jButton1");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(153, 153, 153)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 174, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(182, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(136, 136, 136)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(155, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
                
        investigation ();
        
    }//GEN-LAST:event_jButton1ActionPerformed

    
    public void investigation ()
    {
        /*try
        {
            da.connect ();
            da.executeQuery ("select revision, filepath, changetype, startline, endline from changes order by revision");

            while (da.result.next())
            {
                System.out.println (da.result.getString("revision") + "\t" + da.result.getString("filepath") + "\t" + da.result.getString("changetype") + "\t" + da.result.getString("startline") + "\t" + da.result.getString("endline"));
            }
            da.disconnect ();
        }
        catch (Exception e)
        {            
        }*/
        
        int cloneType = Integer.parseInt(JOptionPane.showInputDialog("Clone Type ? "));
        analyzeContextBugsInCodeClones (cloneType);        
    }
    
    public void investigation2 ()
    {
        int cloneType = Integer.parseInt(JOptionPane.showInputDialog("Clone Type ? "));
        //forecastContextBugs(cloneType);
        forecastContestBugsInCodeClones (cloneType);
    }
    
    
    
    public void forecastContestBugsInCodeClones (int clonetype)
    {
        String bugFixCommits = ib.getBugFixCommits();
        
        for (int r = 1;r<cp.revisionCount;r++)
        {
            int changecount = getCloneChangeCount (clonetype, r);
            if (changecount == 0) { continue; }
            
            System.out.println ("analyzing revision = "+r);
            
            SingleClonePair [] pairs = da.getClonePairs(r, clonetype);            
            
            for (int i =0; pairs[i] != null;i++)
            {
                analyzeClonePair (Integer.parseInt(pairs[i].globalcloneid1), Integer.parseInt(pairs[i].globalcloneid2), r, clonetype, bugFixCommits);
            }
            getBugDetectionStatistics ();
        }
    }
    
    
    public int getCloneChangeCount (int clonetype, int revision)
    {
        try
        {
            da.connect ();
            da.executeQuery ("select sum(changecount) ccnt from type"+clonetype+"clones where revision = "+revision);
            da.result.next ();
            int count = Integer.parseInt(da.result.getString ("ccnt"));
            da.disconnect ();
            return count;
        }
        catch (Exception e) {  }
        
        return 0;
    }
    
    
    public void getBugDetectionStatistics ()
    {
        int dcount = 0, truepositives = 0;
        for (int i =0;i<paircount;i++)
        {
            if (potentialpairs[i][2] != -1) {dcount++;}
            if (potentialpairs[i][2] == 1) {truepositives++;}
        }
        System.out.println ("count of potential pairs = "+dcount);
        System.out.println ("count of true positives = "+truepositives);
    }
    
    public float findSimilarityOfClonePair (int gcid1, int gcid2, int revision, int clonetype)
    {
        try
        {
            da.connect ();
            da.executeQuery ("select filepath, startline, endline from type"+clonetype+"clones where revision = "+revision +" and globalcloneid = "+gcid1);
            da.result.next ();
            String file1 = da.result.getString ("filepath");
            int sline1 = Integer.parseInt (da.result.getString ("startline"));
            int eline1 = Integer.parseInt (da.result.getString ("endline"));
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select filepath, startline, endline from type"+clonetype+"clones where revision = "+revision +" and globalcloneid = "+gcid2);
            da.result.next ();
            String file2 = da.result.getString ("filepath");
            int sline2 = Integer.parseInt (da.result.getString ("startline"));
            int eline2 = Integer.parseInt (da.result.getString ("endline"));
            da.disconnect ();            
            
        }
        catch (Exception e) {}
        
        return 0;
    }
    
    
    
    
    
    public void analyzeClonePair (int gcid1, int gcid2, int revision, int clonetype, String bugfixcommits)
    {
        try
        {
            da.connect();
            da.executeQuery ("select count(*) cnt1 from type"+clonetype+"clones where globalcloneid = "+gcid1+" and revision < "+revision+" and changecount > 0");
            da.result.next ();
            int count1 = Integer.parseInt (da.result.getString ("cnt1"));
            da.disconnect ();
            
            da.connect();
            da.executeQuery ("select count(*) cnt2 from type"+clonetype+"clones where globalcloneid = "+gcid2+" and revision < "+revision+" and changecount > 0");
            da.result.next ();
            int count2 = Integer.parseInt (da.result.getString ("cnt2"));
            da.disconnect ();            
            
            if (count1 == 0 || count2 == 0) { insertPotentialPair (gcid1, gcid2, revision); }
            
            int r = revision + 1;
            int bugfix = 0;
            if (bugfixcommits.contains (" "+r+" "))
            {
                bugfix = 1;
            }
            
            da.connect ();
            da.executeQuery ("select changecount from type"+clonetype+"clones where revision = "+revision+" and globalcloneid = "+gcid1);
            da.result.next ();
            int cc1 = Integer.parseInt (da.result.getString ("changecount"));
            da.disconnect ();

            da.connect ();
            da.executeQuery ("select changecount from type"+clonetype+"clones where revision = "+revision+" and globalcloneid = "+gcid2);
            da.result.next ();
            int cc2 = Integer.parseInt (da.result.getString ("changecount"));
            da.disconnect ();

            updatePotentialPair (gcid1, gcid2, count1, count2, cc1, cc2, bugfix);                       
        }
        catch (Exception e)
        {
            
        }
    }
    
    public void insertPotentialPair (int gcid1, int gcid2, int revision)
    {
        for (int i =0;i<paircount;i++)
        {
            if ((potentialpairs[i][0] == gcid1 && potentialpairs[i][1] == gcid2)||(potentialpairs[i][0] == gcid2 && potentialpairs[i][1] == gcid1))
            {
                return;
            }
        }
        potentialpairs[paircount][0]=gcid1; potentialpairs[paircount][1]=gcid2; potentialpairs[paircount][2]=0;
        potentialpairsrevisions[paircount]=revision;
        paircount++;
    }
    
    public void updatePotentialPair (int gcid1, int gcid2, int pcount1, int pcount2, int count1, int count2, int bugfix)
    {
        for (int i =0;i<paircount;i++)
        {
            if ((potentialpairs[i][0] == gcid1 && potentialpairs[i][1] == gcid2)||(potentialpairs[i][0] == gcid2 && potentialpairs[i][1] == gcid1))
            {
                if (potentialpairs[i][2] == 1) {return;}
                if (potentialpairs[i][2] == -1) {return;}
                
                if (bugfix == 1)
                {
                    if (count1 > 0 && pcount1 == 0 && count2 == 0) { potentialpairs[i][2] = 1; }
                    if (count2 > 0 && pcount2 == 0 && count1 == 0) {potentialpairs[i][2] = 1;}
                }
                if (pcount1 > 0 && pcount2 > 0) { potentialpairs[i][2] =-1; }
                
                //if (count1 == 1 && count2 == 1) { potentialpairs[i][2] =-1; return; }
                //if (bugfix == 0 && count1 == 0 && count2 == 0) { return; }
                //if (bugfix == 0)
            }
        }
    }
                       
    public void forecastContextBugs (int clonetype)
    {
        try
        {
            int [][] pairs = new int[5000][2];
            int paircount = 0;
            
            String clones = "", clone = "";
            
            int [][] potentialclones = new int[10000][2]; //first index = potential globalcloneid, second index = whether it experienced a bug-fix or not.
            int pcount = 0;
            
            String bugFixCommits = ib.getBugFixCommits();

            for (int r =1;r<cp.revisionCount;r++)
            {
                

                //getting all clones.
                paircount = 0;
                da.connect ();
                da.executeQuery ("select globalcloneid from type"+clonetype+"clones where revision = "+r);
                while (da.result.next ())
                {
                    clone = da.result.getString ("globalcloneid");
                    if (!clones.contains (" " + clone + " ")) { clones += " " + clone + " "; }
                }
                da.disconnect ();
                
                
                
                //find the potential globalcloneids by checking the past evolutionary history of the clone pairs.
                int cnt = clones.trim().split("[ ]+").length;
                for (int i =0;i<cnt;i++)
                {
                    clone = clones.trim().split("[ ]+")[i].trim();
                    
                    //did this clone change previously?
                    da.connect ();
                    da.executeQuery ("select count(*) cnt from type"+clonetype+"clones where changecount > 0 and revision < "+r+" and globalcloneid = "+clone+"");
                    da.result.next ();
                    int p = Integer.parseInt (da.result.getString("cnt"));
                    da.disconnect ();
                    if (p == 0)
                    {
                        //insert in the set of potential clones.
                        pcount = insertPotentialClones (potentialclones, pcount, Integer.parseInt(clone));
                    }
                }
                
                
                if (bugFixCommits.contains (" "+(r+1)+" "))
                {
                    
                }
                
                
            }
        }
        catch (Exception e) {}
    }
    
    
    public int updatePotentialClones (int pclones [][], int pcount2, int gcid, int changed)
    {
        int i =0, pcount = pcount2;
        for (i =0;i<pcount;i++)
        {
            if (pclones[i][0] == gcid) 
            {
                if (changed > 0) { pclones[i][1] = -1; }
                break;
            }            
        }
        if (i == pcount) 
        { 
            if (changed == 0)
            {
                pclones[i][0] = gcid; pclones[i][1] = 0; pcount++; 
            }
        }
        return pcount;        
    }
    
    
    public int insertPotentialClones (int pclones[][], int pcount2, int gcid)
    {
        int i =0, pcount = pcount2;
        for (i =0;i<pcount;i++)
        {
            if (pclones[i][0] == gcid) {break;}            
        }
        if (i == pcount) { pclones[i][0] = gcid; pclones[i][1] = 0; pcount++; }
        return pcount;
    }
    
    
    
    public void analyzeContextBugsInCodeClones (int cloneType)
    {
        String bugFixCommits = ib.getBugFixCommits();
        
        int pattern1Count = 0, pattern2Count = 0;
        
        int countContextBugs = 0, countCloneBugs = 0, countBugs=0, countContextBugsPattern1 = 0, countContextBugsPattern2 = 0;
        String pattern1Bugs = "", pattern2Bugs = "";
        String clonesWithContextBugs = "";
        int differentFilePairs = 0, sameFilePairs = 0, methodClonePairs = 0, blockClonePairs = 0;
        
        
        for (int r = 1;r<cp.revisionCount; r++)
        {            
            int contextBugFixFlag = 0;
            if (!bugFixCommits.contains (" "+(r+1)+" ")) {continue;}
            countBugs++;
            
            String changedClones = getChangedClones (cloneType, r);
            if (changedClones.trim().length() == 0) {continue;}
            
            countCloneBugs++;
            
            int l = changedClones.trim().split("[ ]+").length;
            for (int i =0;i<l;i++)
            {
                int changedClone = Integer.parseInt(changedClones.trim().split("[ ]+")[i].trim());
                String otherClonesInPair = getClonesThatMadePairWithCloneID (Integer.parseInt(changedClone+""), cloneType, r);
                String otherClonesInPairNotChanged = getSet1MinusSet2(otherClonesInPair, changedClones);
                String otherClonesInPairChanged = getSet1MinusSet2 (otherClonesInPair, otherClonesInPairNotChanged);
                
                if (otherClonesInPairNotChanged.trim().length() == 0){continue;}
                //System.out.println ("changed clone = "+changedClone+", unchanged clones = "+otherClonesInPairNotChanged);
                int l2 = otherClonesInPairNotChanged.trim().split("[ ]+").length;
                for (int j =0;j<l2;j++)
                {
                    int notChangedClone = Integer.parseInt (otherClonesInPairNotChanged.trim().split("[ ]+")[j].trim());
                    
                    if (changedClone == -1 || notChangedClone == -1) {continue;}
                    
                    System.out.println ("\t Revision = "+ r +", Changed = "+changedClone + ", Not Changed = "+notChangedClone);
                    
                    if (checkPattern1 (changedClone, notChangedClone, r, cloneType) == 1)
                    {
                        pattern1Count++;
                        contextBugFixFlag = 1;
                        if (!pattern1Bugs.contains (" "+(r+1)+" ") && !pattern2Bugs.contains (" "+(r+1)+" "))
                        {
                            pattern1Bugs += " "+(r+1)+" ";
                        }                                                
                        
                        if (!clonesWithContextBugs.contains (" "+changedClone+" ")) { clonesWithContextBugs += " "+changedClone+" "; }
                        
                        String result = analyzeClonePair (changedClone, notChangedClone, r, cloneType);
                        if (result.charAt(0) == '1') { sameFilePairs++; }
                        if (result.charAt(0) == '0') { differentFilePairs++; }
                        if (result.charAt(2) == '1') { methodClonePairs++; }
                        if (result.charAt(2) == '0') { blockClonePairs++; }
                        
                        vc.cloneType = cloneType;
                        vc.codeid = changedClone;
                        vc.codetype = "clone";
                        vc.commit = r;
                        vc.showChangesInTable2();
                        
                        vc.cloneType = cloneType;
                        vc.codeid = notChangedClone;
                        vc.codetype = "clone";
                        vc.commit = r;
                        vc.showChangesInTable2();
                        
                    }
                    else if (checkPattern2 (changedClone, notChangedClone, r, cloneType) == 1)
                    {
                        pattern2Count++;
                        contextBugFixFlag = 1;
                        
                        if (!pattern1Bugs.contains (" "+(r+1)+" ") && !pattern2Bugs.contains (" "+(r+1)+" "))
                        {
                            pattern2Bugs += " "+(r+1)+" ";
                        }                        
                        
                        if (!clonesWithContextBugs.contains (" "+changedClone+" ")) { clonesWithContextBugs += " "+changedClone+" "; }
                        
                        String result = analyzeClonePair (changedClone, notChangedClone, r, cloneType);
                        if (result.charAt(0) == '1') { sameFilePairs++; }
                        if (result.charAt(0) == '0') { differentFilePairs++; }
                        if (result.charAt(2) == '1') { methodClonePairs++; }
                        if (result.charAt(2) == '0') { blockClonePairs++; }   
                        
                        
                        vc.cloneType = cloneType;
                        vc.codeid = changedClone;
                        vc.codetype = "clone";
                        vc.commit = r;
                        vc.showChangesInTable2();
                        
                        vc.cloneType = cloneType;
                        vc.codeid = notChangedClone;
                        vc.codetype = "clone";
                        vc.commit = r;
                        vc.showChangesInTable2();                        
                        
                    }
                }
            }
            if (contextBugFixFlag == 1) { countContextBugs++; }
        }
        
        if (pattern1Bugs.trim().length() > 0)
        {
            countContextBugsPattern1 = pattern1Bugs.trim().split("[ ]+").length;
        }
        if (pattern2Bugs.trim().length() > 0)
        {
            countContextBugsPattern2 = pattern2Bugs.trim().split("[ ]+").length;
        }
        
        
        //getting the total number of distinct clone fragments.
        int cloneCount = 0;
        try
        {            
            da.connect ();
            da.executeQuery ("select count(distinct(globalcloneid)) cnt from type"+cloneType+"clones");
            da.result.next();
            cloneCount = Integer.parseInt(da.result.getString ("cnt"));
            da.disconnect ();
        }
        catch (Exception e)
        { }
                                
        System.out.println ("Count of all bug-fixes = "+countBugs);
        System.out.println ("Count of all bug-fixes in clones = "+countCloneBugs);
        System.out.println ("Count of context bug-fix = "+countContextBugs);
        System.out.println ("Count of context bug fix (Pattern 1) = "+countContextBugsPattern1);
        System.out.println ("Count of context bug fix (Pattern 2) = "+countContextBugsPattern2);        
        System.out.println ("pattern 1 count = "+pattern1Count);
        System.out.println ("pattern 2 count = "+pattern2Count);
        System.out.println ("count of all clones created during evolution = "+cloneCount);
        System.out.println ("Count of distinct clones that contain context bugs = "+clonesWithContextBugs.trim().split("[ ]+").length);
        System.out.println ("\nNo. of clone pairs related with context bugs = "+(pattern1Count+pattern2Count));
        System.out.println ("No. of context-bug pairs where two clone fragments reside in different files = "+differentFilePairs);
        System.out.println ("No. of context-bug pairs where two clone fragments reside in the same file = "+sameFilePairs);
        System.out.println ("No. of context-bug pairs where two clone fragments are methods = "+methodClonePairs);
        System.out.println ("No. of context-bug pairs where two clone fragments are blocks = "+blockClonePairs);
        
    }
    
    
    public String analyzeClonePair (int gcid1, int gcid2, int revision, int cloneType)
    {
        try
        {            
            da.connect ();
            da.executeQuery ("select filepath, methodid, startline, endline from type"+cloneType+"clones where revision = "+revision+" and globalcloneid = "+gcid1+" ");
            da.result.next ();
            String filepath1 = da.result.getString ("filepath");
            int mid1 = Integer.parseInt (da.result.getString("methodid"));
            int clonelength1 = Integer.parseInt (da.result.getString("endline")) - Integer.parseInt (da.result.getString("startline")) + 1;
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select startline, endline from methods where revision = "+revision+" and methodid = "+mid1+" ");
            da.result.next ();
            int methodlength1 = Integer.parseInt (da.result.getString("endline")) - Integer.parseInt (da.result.getString("startline")) + 1;
            da.disconnect ();
            
            
            da.connect ();
            da.executeQuery ("select filepath, methodid, startline, endline from type"+cloneType+"clones where revision = "+revision+" and globalcloneid = "+gcid2+" ");
            da.result.next ();
            String filepath2 = da.result.getString ("filepath");
            int mid2 = Integer.parseInt (da.result.getString("methodid"));
            int clonelength2 = Integer.parseInt (da.result.getString("endline")) - Integer.parseInt (da.result.getString("startline")) + 1;
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select startline, endline from methods where revision = "+revision+" and methodid = "+mid2+" ");
            da.result.next ();
            int methodlength2 = Integer.parseInt (da.result.getString("endline")) - Integer.parseInt (da.result.getString("startline")) + 1;
            da.disconnect ();
            
            int sameFile = 0;
            int methodClones = 0;
            if (filepath1.equals (filepath2)) { sameFile = 1; }
            if (methodlength1 - clonelength1 < 2 && methodlength2 - clonelength2 < 2) { methodClones = 1; }
            
            return ""+sameFile+" " + methodClones+"";
        }
        catch (Exception e) {  }
        return "- -";
    }
    
    
    public int checkPattern1 (int changedClone, int nonChangedClone, int bugfixCommit, int cloneType)
    {
        try
        {
            da.connect ();
            da.executeQuery ("select min(revision) mr from type"+cloneType+"clones where globalcloneid = "+changedClone);
            da.result.next ();
            int mrChanged = Integer.parseInt (da.result.getString ("mr"));
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select min(revision) mr from type"+cloneType+"clones where globalcloneid = "+nonChangedClone);
            da.result.next ();
            int mrNonChanged = Integer.parseInt (da.result.getString ("mr"));
            da.disconnect ();
            
            if (mrNonChanged >= mrChanged) {return 0;}
            
            da.connect ();
            da.executeQuery ("select count(*) c from type"+cloneType+"clones where globalcloneid = '"+changedClone+"' and changecount > 0 and revision > '"+mrChanged+"' and revision < '"+bugfixCommit+"'");
            da.result.next ();
            int cc = Integer.parseInt (da.result.getString ("c"));
            da.disconnect ();
            
            if (cc == 0) 
            { 
                if (experiencedBugFix(nonChangedClone, cloneType, mrChanged) == 1) {return 0;}
                
                float disc = cpattern.checkDiscSimilarity(changedClone, nonChangedClone, cloneType, bugfixCommit);
                System.out.println ("pattern1111111111111: changed clone = "+changedClone+" (created = "+mrChanged+"), non-changed = "+nonChangedClone+" (created = "+mrNonChanged+"), change count of Changed clone before bug-fix = "+cc+", disc = "+disc);
                return 1; 
            }
        }
        catch (Exception e) { return 0; }
        
        return 0;
    }
    
    
    public int experiencedBugFix (int gcid, int cloneType, int afterCommit)
    {
        try
        {
            int result = 0;
            String bugFixCommits = ib.getBugFixCommits();
            String changeRevisions = "";

            da.connect ();
            da.executeQuery ("select revision from type"+cloneType+"clones where globalcloneid = "+gcid+" and changecount > 0 and revision > "+afterCommit);
            while (da.result.next())
            {
                changeRevisions += " " + (Integer.parseInt ("revision")+1) + " ";
            }
            da.disconnect ();

            int l = changeRevisions.trim().length();
            if (l > 0)
            {
                l = changeRevisions.trim().split("[ ]+").length;
            }
            
            String id = "";
            for (int i =0;i<l;i++)
            {
                id = changeRevisions.trim().split("[ ]+")[i].trim();
                if (bugFixCommits.contains (" " + id + " ")) {return 1;}
            }

            return result;
        }
        catch (Exception e)
        {
            return 0;
        }
    }
    
    public int checkPattern2 (int changedClone, int nonChangedClone, int bugfixCommit, int cloneType)
    {
        try
        {
            da.connect ();
            da.executeQuery ("select min(revision) mr from type"+cloneType+"clones where globalcloneid = "+changedClone);
            da.result.next ();
            int mrChanged = Integer.parseInt (da.result.getString ("mr"));
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select min(revision) mr from type"+cloneType+"clones where globalcloneid = "+nonChangedClone);
            da.result.next ();
            int mrNonChanged = Integer.parseInt (da.result.getString ("mr"));
            da.disconnect ();
            
            if (mrNonChanged != mrChanged) {return 0;}
            
            da.connect ();
            da.executeQuery ("select count(*) c from type"+cloneType+"clones where globalcloneid = '"+changedClone+"' and changecount > 0 and revision > '"+mrChanged+"' and revision < '"+bugfixCommit+"'");
            da.result.next ();
            int cc = Integer.parseInt (da.result.getString ("c"));
            da.disconnect ();
            
            if (cc == 0) 
            { 
                if (experiencedBugFix(nonChangedClone, cloneType, mrChanged) == 1) {return 0;}
                
                float disc = cpattern.checkDiscSimilarity(changedClone, nonChangedClone, cloneType, bugfixCommit);
                System.out.println ("pattern2222222222222: changed clone = "+changedClone+" (created = "+mrChanged+"), non-changed = "+nonChangedClone+" (created = "+mrNonChanged+"), change count of Changed clone before bug-fix = "+cc+", disc = "+disc);
                return 1; 
            }
        }
        catch (Exception e) { return 0; }
        
        return 0;        
    }
    
    
    public String getChangedClones (int cloneType, int revision)
    {        
        String result = "";
        
        try
        {
            da.connect ();
            da.executeQuery ("select globalcloneid from type"+cloneType+"clones where revision = "+revision+" and changecount > 0");
            while (da.result.next ())
            {
                int gcid = Integer.parseInt (da.result.getString("globalcloneid"));
                if (vc.isChanged(gcid, cloneType, revision) == 1)
                {
                    result += " " + da.result.getString("globalcloneid") + " ";
                }
            }
            da.disconnect ();
        }
        catch (Exception e)
        {
            
        }
        
        return result;
    }  
    
    public String getClonesThatMadePairWithCloneID (int gcid, int cloneType, int revision)
    {
        String result = "";
        try
        {            
            int gcid1 = 0, gcid2 = 0, toadd = 0;
                        
            da.connect();
            da.executeQuery ("select globalcloneid1, globalcloneid2 from type"+cloneType+"clonepairs where (globalcloneid1 = "+gcid+" or globalcloneid2 = "+gcid+") and revision = "+revision);
            while (da.result.next ())
            {
                gcid1 = Integer.parseInt(da.result.getString ("globalcloneid1"));
                gcid2 = Integer.parseInt(da.result.getString ("globalcloneid2"));
                if (gcid1 == gcid) { toadd = gcid2; }
                if (gcid2 == gcid) {toadd = gcid1;}
                
                if (!result.contains (" "+toadd+" ")) { result += " " + toadd + " "; }
            }
            da.disconnect ();
        }
        catch (Exception e)
        {
            //
        }
        return result;
    }
    
    public String getSet1MinusSet2 (String set1, String set2)
    {
        String result = "", id = "";        
        
        int l1 = set1.trim().split("[ ]+").length;
        for (int i =0;i<l1;i++)
        {
            id = set1.trim().split("[ ]+")[i].trim();
            if (!set2.contains (" "+id+" ")) { result += " " + id + " "; }
        }
        
        return result;
    }  
    
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ContextBugs.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ContextBugs.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ContextBugs.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ContextBugs.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ContextBugs().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    // End of variables declaration//GEN-END:variables
}
