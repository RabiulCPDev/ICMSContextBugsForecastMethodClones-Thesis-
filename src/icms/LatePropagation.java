/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package icms;

import javax.swing.JFrame;
import java.io.*;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author mani
 */

class LatePropagationClonePair
{
    int gcid1=-1, gcid2=-1;
    int divergedAfterRevision = -1;
    int convergedInRevision = -1;
    int isAcceptable = 0;
}


public class LatePropagation extends javax.swing.JFrame {

    
    CommonParameters cp = new CommonParameters ();
    CommonMethods cm = new CommonMethods ();
    
    AttributeNames an = new AttributeNames ();
    
    //necessary for code visualization
    VisualizeCode vc1 = new VisualizeCode ();
    VisualizeCode vc2 = new VisualizeCode ();
    
    /**
     * Creates new form LatePropagation
     */
    public LatePropagation() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jButton11 = new javax.swing.JButton();
        jButton16 = new javax.swing.JButton();
        jButton19 = new javax.swing.JButton();
        jButton22 = new javax.swing.JButton();
        jButton25 = new javax.swing.JButton();
        jButton28 = new javax.swing.JButton();
        jButton31 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jButton6 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton1.setText("Get Late Propagation Clone Pairs");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton3.setText("Get Late Propagation Clones");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jButton2.setText("Analyze Late Propagations");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton4.setText("Analyze Evolutionary Coupling to Minimize Late Propagation");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jButton11.setText("Percentage of Late Propagation Clones that are SPCP Clones");
        jButton11.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton11ActionPerformed(evt);
            }
        });

        jButton16.setText("Analyze Bug-Proneness of Late Propagations");
        jButton16.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton16ActionPerformed(evt);
            }
        });

        jButton19.setText("Update Late Propagation Clone Pairs");
        jButton19.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton19ActionPerformed(evt);
            }
        });

        jButton22.setText("Clone fragments in the late propagation pair remain in different files");
        jButton22.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton22ActionPerformed(evt);
            }
        });

        jButton25.setText("Clone fragment(s) in late propagation is/are block clones");
        jButton25.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton25ActionPerformed(evt);
            }
        });

        jButton28.setText("Number of distinct clone pairs");
        jButton28.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton28ActionPerformed(evt);
            }
        });

        jButton31.setText("disappearance and reappear 1");
        jButton31.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton31ActionPerformed(evt);
            }
        });

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null},
                {null},
                {null},
                {null}
            },
            new String [] {
                "Title 1"
            }
        ));
        jTable1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTable1MouseClicked(evt);
            }
        });
        jScrollPane1.setViewportView(jTable1);

        jButton6.setText("Load Late Propagation in Table");
        jButton6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton6ActionPerformed(evt);
            }
        });

        jLabel1.setText("Clone Type = ");

        jTextField1.setText("jTextField1");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(jButton31)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButton3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(jButton1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton16, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton22, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton25, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton11, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton28, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton19, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane1)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(jButton6, javax.swing.GroupLayout.PREFERRED_SIZE, 284, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jTextField1, javax.swing.GroupLayout.DEFAULT_SIZE, 93, Short.MAX_VALUE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButton1)
                .addGap(18, 18, 18)
                .addComponent(jButton2)
                .addGap(18, 18, 18)
                .addComponent(jButton16)
                .addGap(18, 18, 18)
                .addComponent(jButton22)
                .addGap(16, 16, 16)
                .addComponent(jButton25)
                .addGap(18, 18, 18)
                .addComponent(jButton11)
                .addGap(18, 18, 18)
                .addComponent(jButton4)
                .addGap(18, 18, 18)
                .addComponent(jButton28)
                .addGap(18, 18, 18)
                .addComponent(jButton19, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton31)
                    .addComponent(jButton3))
                .addGap(32, 32, 32)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 109, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton6)
                    .addComponent(jLabel1)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 37, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
                
        int clonetype = getCloneType ();
        getLatePropagationClonePairs (clonetype);
        showFinishedMessage ("Late propagation clone pairs (Type "+clonetype+" case) stored.");
    }//GEN-LAST:event_jButton1ActionPerformed

    public void showFinishedMessage (String message)
    {
        JOptionPane.showMessageDialog(this, message);
    }
    
    
    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        // TODO add your handling code here:
        
        getLatePropagationClones(getCloneType ());
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // TODO add your handling code here:      
        
        int clonetype = getCloneType ();
        analyzeLatePropagations (clonetype);
        showFinishedMessage ("Analysis of late propagations done (Type "+clonetype+" case)");
    }//GEN-LAST:event_jButton2ActionPerformed

    
    public int getCloneType ()
    {
        int clonetype = 0;
        String type = JOptionPane.showInputDialog("Clone Type ?");
        clonetype = Integer.parseInt (type);        
        return clonetype;
    }
    
    
    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        // TODO add your handling code here:
        
        analyzeEvolutionaryCouplingToMinimizeLatePropagation (getCloneType ());
        
    }//GEN-LAST:event_jButton4ActionPerformed

    
    public void getStatistics (int cloneType)
    {
        String lastrevisionclones = " "+cm.getClonesInRevision(cp.revisionCount, cloneType)+" ";
        String spcpClones = "";
        SPCPCloneDetection spcpcd = new SPCPCloneDetection ();
        try
        {
            spcpClones = " "+spcpcd.getSPCPClones(cloneType)+" ";
        }
        catch (Exception e)
        {
            System.out.println ("error in method getSPCPClones.");
        }
        
        //getting the late propagation clones.
        
        String lpClones = getLatePropagationClones (cloneType);
        
        String commonClones = "";
        String lpclone = "";
        int l = lpClones.trim().split("[ ]+").length;
        
        for (int i =0;i<l;i++)
        {
            lpclone = lpClones.trim().split("[ ]+")[i].trim();
            if (spcpClones.contains(" "+lpclone+" "))
            {
                commonClones += " " + lpclone + " ";
            }
        }
        
        int spcpCloneCount = spcpClones.trim().split("[ ]+").length;
        int lpCloneCount = lpClones.trim().split("[ ]+").length;
        int commonCloneCount = commonClones.trim().split("[ ]+").length;
        
        //how many of the late propagations include these common clones?
        
        String spcppairs = "";
        String nonspcppairs = "";
        
        LatePropagationClonePair [] lpcPairs = readLatePropagationClonePairs(cloneType);
        int i =0;
        int totalcount = 0;
        int minimizecount = 0;
        while (lpcPairs[i] != null)
        {
            if (cloneType == 3)
            {
                if (lpcPairs[i].isAcceptable == 0)
                {
                    i++;
                    continue;
                }
            }
            /*if (!lastrevisionclones.contains(" " + lpcPairs[i].gcid1 + " " ) || !lastrevisionclones.contains(" " + lpcPairs[i].gcid2 + " " ))
            {
                i++;
                continue;
            }*/
            totalcount++;
            if (spcpClones.contains (" " + lpcPairs[i].gcid1 + " ") || spcpClones.contains (" " + lpcPairs[i].gcid2 + " "))
            {
                String pair = lpcPairs[i].gcid1+","+lpcPairs[i].gcid2;
                if (!spcppairs.contains (" " + pair+" "))
                {
                    spcppairs += " "  + pair + " ";
                }
                minimizecount++;
            }
            else
            {
                String pair = lpcPairs[i].gcid1+","+lpcPairs[i].gcid2;
                if (!nonspcppairs.contains (" " + pair+" "))
                {
                    nonspcppairs += " "  + pair + " ";
                }                
            }
            i++;
        }
        String message = "\n\n-----------------------------------------------------";
        message += "\nSPCP pair count = "+spcppairs.trim().split("[ ]+").length;
        message += "\nnonSPCP pair count = "+nonspcppairs.trim().split("[ ]+").length;
        message += "\ntotal late propagations = "+totalcount;
        message += "\nminimize count = "+minimizecount;
        message += "\n\n\n\nSPCP clones present in the last revision = "+spcpClones;
        message += "\nLate propagation clones present in the last revision = " + lpClones;
        message += "\nCommon clones = " + commonClones;
        message += "\nNumber of SPCP clones present in the last revision = "+spcpCloneCount;
        message += "\nNumber of late propagation clones present in the last revision = "+lpCloneCount;
        message += "\nNumber of common clones present in the last revision = "+commonCloneCount;
        message += "\nPercentage of late propagation clones that are spcp clones = "+commonCloneCount*100/lpCloneCount;
        
        //JOptionPane.showMessageDialog(this, message);
        
        
        
        System.out.println ("SPCP clones present in the last revision = "+spcpClones);
        System.out.println ("Late propagation clones present in the last revision = " + lpClones);
        System.out.println ("Common clones = " + commonClones);
        System.out.println ("Number of SPCP clones present in the last revision = "+spcpCloneCount);
        System.out.println ("Number of late propagation clones present in the last revision = "+lpCloneCount);
        System.out.println ("Number of common clones present in the last revision = "+commonCloneCount);
        System.out.println ("Percentage of late propagation clones that are spcp clones = "+commonCloneCount*100/lpCloneCount);                 
        
        System.out.println (message);
    }
    
    
    private void jButton11ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton11ActionPerformed
        // TODO add your handling code here:
        
        getStatistics (getCloneType ());       
    }//GEN-LAST:event_jButton11ActionPerformed

    private void jButton16ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton16ActionPerformed
        // TODO add your handling code here:
        
        analyzeBugproneness (getCloneType ());
                
    }//GEN-LAST:event_jButton16ActionPerformed

    private void jButton19ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton19ActionPerformed
        // TODO add your handling code here:
        
        updateLatePropagationClonePairs(getCloneType ());
        
    }//GEN-LAST:event_jButton19ActionPerformed

    private void jButton22ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton22ActionPerformed
        // TODO add your handling code here:
        
        fileAnalysis (getCloneType ());
        
    }//GEN-LAST:event_jButton22ActionPerformed

    private void jButton25ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton25ActionPerformed
        // TODO add your handling code here:
        
        methodCloneAnalysis (getCloneType ());
        
    }//GEN-LAST:event_jButton25ActionPerformed

    private void jButton28ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton28ActionPerformed
        // TODO add your handling code here:
        
        getCountOfDistinctPairs(getCloneType ());
        
        
    }//GEN-LAST:event_jButton28ActionPerformed

    private void jButton31ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton31ActionPerformed
        // TODO add your handling code here:
        
        detectDisappearanceAndReappearance (getCloneType ());
        
    }//GEN-LAST:event_jButton31ActionPerformed

    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton6ActionPerformed
        // TODO add your handling code here:
        
        DefaultTableModel model = (DefaultTableModel) jTable1.getModel();
        model.setRowCount(0);
        String str = "";
        int clonetype = 3;
        //clonetype = getCloneType();
        clonetype = Integer.parseInt (jTextField1.getText ().trim());
        try
        {
            BufferedReader br = new BufferedReader (new InputStreamReader (new FileInputStream (cp.subject_system+"/latepropagations/type"+clonetype+"latepropagations.txt")));
            
            while ((str = br.readLine ())!= null)
            {
                if (str.trim().length ()  == 0) {continue;}
                Object [] row = new Object [1];
                row[0] = str;
                model.addRow(row);
            }
            
        }
        catch (Exception e)
        {
            
        }

    }//GEN-LAST:event_jButton6ActionPerformed

    private void jTable1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTable1MouseClicked
        // TODO add your handling code here:
        
        int selectedrow = jTable1.getSelectedRow();
        if (selectedrow > -1)
        {
            int clonetype = Integer.parseInt (jTextField1.getText ().trim());
            
            String lp = jTable1.getValueAt(selectedrow, 0).toString();
            int clone1 = Integer.parseInt(lp.trim().split("[ ]+")[0].trim());
            int clone2 = Integer.parseInt(lp.trim().split("[ ]+")[1].trim());
            int beginrevision = Integer.parseInt(lp.trim().split("[ ]+")[2].trim());
            int endrevision = Integer.parseInt(lp.trim().split("[ ]+")[3].trim());
            
            
            vc1.cloneType = clonetype;
            vc1.codeid = clone1;
            vc1.codetype = "clone";
            vc1.currentCommit = beginrevision;
            vc1.showChanges();
            vc1.setVisible(true);
            vc1.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
            
                        
            vc2.cloneType = clonetype;
            vc2.codeid = clone2;
            vc2.codetype = "clone";
            vc2.currentCommit = beginrevision;   
            vc2.showChanges();
            vc2.setVisible(true);  
            vc2.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
        }
        
        
    }//GEN-LAST:event_jTable1MouseClicked

    public void detectDisappearanceAndReappearance(int cloneType)
    {
        try
        {
            for (int r = 1; r<= cp.revisionCount;r++)
            {
                BufferedReader br = new BufferedReader (new InputStreamReader (new FileInputStream (cp.subject_system+"/clonedmethods/type"+cloneType+"_clonedmethods_version_"+r+"")));
                String str = "";
                
                while ((str = br.readLine ())!= null)
                {
                    int gcid = Integer.parseInt(cm.getAttributeValueFromString(str, an.globalCloneID));
                    int gmid = Integer.parseInt(cm.getAttributeValueFromString(str, an.globalMethodID));
                    
                    //is gcid present in the next revision?
                    String file = cm.getCloneFile(gcid, r+1, cloneType);
                    if (file.trim().length() > 0) {continue;} //the clone is present. so this is not a disappearance.
                    
                    //does gmid contain any other clone fragments?
                    String clones = cm.getClonesInMethod(gmid, r, cloneType);
                    if (clones.trim().split("[ ]+").length > 1) {continue;} //this method contains some other clones. So, it would not be wise to consider this method.
                    
                    
                    //So, gcid disappears in the next revision. And, also, gcid is the only method in gmid.
                    
                    
                }
            }
        }
        catch (Exception e)
        {
            
        }
    }
    
    
    
    
    public void getCountOfDistinctPairs (int cloneType)
    {
        LatePropagationClonePair [] lpcPairs = readLatePropagationClonePairs(cloneType);
        String distinctPairs = "";
        String distinctClones = "";
        int lpCount = 0;
        int i =0;
        
        while (lpcPairs[i] != null)
        {
            if (cloneType == 3)
            {
                if (lpcPairs[i].isAcceptable == 0)
                {
                    i++;
                    continue;
                }
            }
            
            lpCount++; //counting the number of late propagations.
            
            int c1 = lpcPairs[i].gcid1;
            int c2 = lpcPairs[i].gcid2;
            String pair = c1+","+c2;
            if (!distinctPairs.contains (" "+pair+" "))
            {
                distinctPairs += " " + pair + " ";
            }
            if (!distinctClones.contains(" "+c1+" "))
            {
                distinctClones += " "+c1+" ";
            }
            if (!distinctClones.contains(" "+c2+" "))
            {
                distinctClones += " "+c2+" ";
            }            
            i++;
        }
        int totalClones = cm.getMaxGlobalCloneID(cloneType);
        int tclp = distinctClones.trim().split("[ ]+").length;
        
        String message = "total number of clones = "+totalClones+""
                + "\ntotal number of late propagation clone pairs = "+distinctPairs.trim().split("[ ]+").length+" "
                + "\ntotal number of clones involved with late propagations = "+tclp+""
                + "\nTotal number of late propagations = "+lpCount+" "
                + "\n\npercentage of clones involved with late propagation = "+(float)tclp*100/totalClones+" ";
                
                
                
        System.out.println (message);
        JOptionPane.showMessageDialog(this, message);
    }
    
    
    public void methodCloneAnalysis (int cloneType)
    {
        LatePropagationClonePair [] lpcPairs = readLatePropagationClonePairs (cloneType);
        int i =0, tcount = 0;
        int blockClone = 0;
        String clonepairs = "";
        
        while (lpcPairs[i] != null)
        {
            if (cloneType == 3)
            {
                if (lpcPairs[i].isAcceptable == 0)
                {
                    i++;
                    continue;
                }
            }
            
            String clonepair = lpcPairs[i].gcid1 + "," + lpcPairs[i].gcid2;
            if (!clonepairs.contains (" " + clonepair+" "))
            {
                clonepairs += " " + clonepair + " ";
            }
            else
            {
                i++;
                continue;
            }            
            
            //checking whether any one of the clone fragments is a block clone. 
            if (cm.isMethodClone(lpcPairs[i].gcid1, lpcPairs[i].divergedAfterRevision, cloneType) == 0 || cm.isMethodClone(lpcPairs[i].gcid2, lpcPairs[i].divergedAfterRevision, cloneType) == 0)
            {
                blockClone++;
            }
            tcount++;
            i++;
        }        
        
        String message = "";
        
        message += "\ntotal count = "+tcount;
        message += "\nblock clone = "+blockClone;
        message += "\nmethod clone = "+(tcount-blockClone);
        message += "\npercentage of late propagations where any of the fragments was a block clone = "+ (float)blockClone*100/tcount;
        message += "\npercentage of late propagations where both of the fragments were method clones = "+ (float)(tcount-blockClone)*100/tcount;
        
        System.out.println ("total count = "+tcount);
        System.out.println ("block clone = "+blockClone);
        System.out.println ("method clone = "+(tcount-blockClone));
        System.out.println ("percentage of late propagations where any of the fragments was a block clone = "+ (float)blockClone*100/tcount);
        System.out.println ("percentage of late propagations where both of the fragments were method clones = "+ (float)(tcount-blockClone)*100/tcount);        

        JOptionPane.showMessageDialog(this, message);
    }
    
    public void fileAnalysis (int cloneType)
    {
        LatePropagationClonePair [] lpcPairs = readLatePropagationClonePairs (cloneType);
        int i =0, tcount = 0;
        int sameFile = 0;
        
        String clonepairs = "";
        
        while (lpcPairs[i] != null)
        {
            if (cloneType == 3)
            {
                if (lpcPairs[i].isAcceptable == 0)
                {
                    i++;
                    continue;
                }
            }
            
            String clonepair = lpcPairs[i].gcid1 + "," + lpcPairs[i].gcid2;
            if (!clonepairs.contains (" " + clonepair+" "))
            {
                clonepairs += " " + clonepair + " ";
            }
            else
            {
                i++;
                continue;
            }
           
            
            String file1 = cm.getCloneFile(lpcPairs[i].gcid1, lpcPairs[i].divergedAfterRevision, cloneType);
            String file2 = cm.getCloneFile(lpcPairs[i].gcid2, lpcPairs[i].divergedAfterRevision, cloneType);
            if (file1.equals (file2))
            {
                sameFile++;
            }
            tcount++;
            i++;
        }
        
        
        String message = "";
        
        
        message += "\ntotal late propagation pairs = "+tcount;
        message += "\nsame File = "+sameFile;
        message += "\ndifferent Files = "+(tcount-sameFile);
        message += "\npercentage of late propagations where the clone fragments in each late propagation pair remain in different files = "+(float)(tcount-sameFile)*100/tcount;
        message += "\npercentage of late propagations where the clone fragments in each late propagation pair remain in the same file = "+(float)sameFile*100/tcount;
        
        System.out.println ("total late propagations = "+tcount);
        System.out.println ("same File = "+sameFile);
        System.out.println ("different Files = "+(tcount-sameFile));
        System.out.println ("percentage of late propagations where the clone fragments in each late propagation pair remain in different files = "+(float)(tcount-sameFile)*100/tcount);
        System.out.println ("percentage of late propagations where the clone fragments in each late propagation pair remain in the same file = "+(float)sameFile*100/tcount);
        
        JOptionPane.showMessageDialog(this, message);
    }
    
    public void analyzeBugproneness (int cloneType)
    {
        //getting the bug-fix commits.
        try
        {
            BufferedReader br = new BufferedReader (new InputStreamReader (new FileInputStream (cp.subject_system+"/commitlog.txt")));
            String str = "";
            String bugFixCommits = "";
            String prevString = "";
            
            int commit = 0;
            while ((str = br.readLine())!= null)
            {
                if (str.trim().length() == 0) {continue;}
                
                if (prevString.contains ("--------------------------------"))
                {
                    //this is the starting of a commit report.
                    //we need to know the commit number.
                    String str1 = str.trim().split("[ ]+")[0].trim();
                    str1 = str1.substring(1);
                    commit = Integer.parseInt (str1);
                }
                else
                {
                    //according to the study of Mockus
                    if (str.contains ("bug") || str.contains("fix") || str.contains ("fixup") || str.contains ("error") || str.contains ("fail"))
                    //if (str.contains ("bug"))
                    {
                        if (!bugFixCommits.contains (" "+commit+" "))
                        {
                            bugFixCommits += " " + commit + " ";
                        }
                    }
                }
                prevString = str;
            }
            br.close();
            System.out.println ("revisions that were created because of a bug fix = "+bugFixCommits);
            
            String buggylatepropagationclones = "";
            int buggyLatePropagations = 0;
            int totalLatePropagations = 0;
            BufferedReader br2 = new BufferedReader (new InputStreamReader (new FileInputStream (cp.subject_system+"/latepropagations/type"+cloneType+"latepropagations.txt")));
            while ((str = br2.readLine()) != null)
            {
                if (str.trim().length() == 0) {continue;}                                
                
                int gcid1=0, gcid2=0, divAfter=0, convIn = 0, isAccept = 0;
                gcid1 = Integer.parseInt(str.trim().split("[ ]+")[0].trim());
                gcid2 = Integer.parseInt(str.trim().split("[ ]+")[1].trim());
                divAfter = Integer.parseInt(str.trim().split("[ ]+")[2].trim());
                convIn = Integer.parseInt(str.trim().split("[ ]+")[3].trim());
                isAccept = Integer.parseInt(str.trim().split("[ ]+")[4].trim());
                
                //if the divergence did not happen because of changes in the matched portions
                //we do not need to consider that late propagation.                
                if (cloneType == 3)
                {
                    if (isAccept == 0)
                    {
                        continue;
                    }
                }
                
                totalLatePropagations++;
                
                System.out.println ("checking late propagation = "+totalLatePropagations);
                
                String bugFixRevisions = bugFixCommits;
                
                int begin = divAfter+1, end = convIn;
                
                
                //bug fix happens in the converging commit.
                //begin = convIn; end = convIn;
                
                for (int i =begin;i<=end;i++)
                {
                    if (bugFixRevisions.contains (" " + i + " "))
                    {
                        int changes1 = cm.getChangesToClone(i-1, gcid1, cloneType);
                        int changes2 = cm.getChangesToClone(i-1, gcid2, cloneType);
                        
                        if (changes1 > 0 || changes2 > 0)
                        {
                            if (!buggylatepropagationclones.contains (" " + gcid1 + " "))
                            {
                                buggylatepropagationclones += " " + gcid1 + " ";
                            }
                            if (!buggylatepropagationclones.contains (" " + gcid2 + " "))
                            {
                                buggylatepropagationclones += " " + gcid2 + " ";
                            }                            
                            
                            buggyLatePropagations++;
                            break;
                        }
                    }
                }                
            }
            
            
            String message = "";
            
            message += "\ntotal late propagations = "+totalLatePropagations;
            message += "\nbuggy late propagations = "+buggyLatePropagations ;
            
            System.out.println ("total late propagations = "+totalLatePropagations);
            System.out.println ("buggy late propagations = "+buggyLatePropagations);
            
            //percentage of SPCP clones that experience buggy late propagations.
            SPCPCloneDetection spcpcd = new SPCPCloneDetection ();
            String spcpclones = spcpcd.getSPCPClones(cloneType);
            
            int buggyspcp = 0, buggynonspcp = 0;
            
            //how many of the buggylatepropagationclones are spcp clones.
            int l = buggylatepropagationclones.trim().split("[ ]+").length;
            
            for (int i =0;i<l;i++)
            {
                String buggyclone = buggylatepropagationclones.trim().split("[ ]+")[i].trim();
                if (spcpclones.contains (" "+buggyclone+" "))
                {
                    buggyspcp++;
                }
                else
                {
                    buggynonspcp++;
                }
            }
            
            message += "\nnumber of buggy late propagation clones = "+(buggyspcp+buggynonspcp);
            message += "\nnumber of buggy spcpclones = "+buggyspcp;
            message += "\nnumber of buggy nonspcpclones = "+buggynonspcp;
            
            System.out.println ("number of buggy late propagation clones = "+(buggyspcp+buggynonspcp));
            System.out.println ("number of buggy spcpclones = "+buggyspcp);
            System.out.println ("number of buggy nonspcpclones = "+buggynonspcp);            
            
            JOptionPane.showMessageDialog(this, message);
            
        }
        catch (Exception e)
        {
            System.out.println ("error in method = analyzeBugproneness. "+e);
        }
        
    }
    
    public int checkDisappearanceAndReappearance (int gcid1, int gcid2, int divergedAfter, int currentRevision, int cloneType)
    {
        int cls1 = -1, cls2 = -1, reapp1 = 0, reapp2 = 0;
        if (hasReappeared (gcid1, divergedAfter, currentRevision, cloneType) == 1)
        {
            int mid = cm.getContainerMethodID(gcid1, divergedAfter, cloneType);
            int clone = Integer.parseInt(cm.getClonesInMethod(mid, currentRevision, cloneType).trim());
            int cls = cm.getCloneClass(currentRevision, clone, cloneType);
            cls1 = cls;
            reapp1 = 1;
        }
        else
        {
            cls1 = cm.getCloneClass(currentRevision, gcid1, cloneType);
            reapp1 = 0;
        }
        if (hasReappeared (gcid2, divergedAfter, currentRevision, cloneType) == 1)
        {
            int mid = cm.getContainerMethodID(gcid2, divergedAfter, cloneType);
            int clone = Integer.parseInt(cm.getClonesInMethod(mid, currentRevision, cloneType).trim());
            int cls = cm.getCloneClass(currentRevision, clone, cloneType);
            cls2 = cls;
            reapp2 = 1;
        }
        else
        {
            cls2 = cm.getCloneClass(currentRevision, gcid2, cloneType);
            reapp2 = 0;
        }
        
        if (reapp1 == 1 || reapp2 == 1)
        {
            if (cls1 == cls2)
            {
                return 1;
            }
        }
        return 0;
    }
    
    public int hasReappeared (int gcid1, int disappearedAfter, int reappearedIn, int cloneType)
    {
        //check disappearance.
        int cls1 = cm.getCloneClass(disappearedAfter+1, gcid1, cloneType);
        if (cls1 == -1)
        {
            //disappeared.
            int gmid1 = cm.getContainerMethodID(gcid1, disappearedAfter, cloneType);
            String clones = cm.getClonesInMethod(gmid1, disappearedAfter, cloneType);
            if (clones.trim().length () > 0 && clones.trim().split("[ ]+").length > 1) {return 0;}
            
            //is reappeared?
            String clones2 = cm.getClonesInMethod(gmid1, reappearedIn, cloneType);
            if (clones2.trim().length() > 0 && clones.trim().split("[ ]+").length == 1)
            {
                //reappeared.                
                return 1;
            }
        }  
        else
        {
            return 0;
        }
        return 0;
    }
    
    public int makePair (int gcid1, int gcid2, SingleClonePair [] pairs)            
    {
        int makes = 0;
        
        if (gcid1 == -1 || gcid2 == -1) {return 0;}
        
        for (int i =0;pairs[i] != null;i++)
        {
            if ((pairs[i].globalcloneid1.equals (gcid1+"") && pairs[i].globalcloneid2.equals (gcid2+""))
                || (pairs[i].globalcloneid1.equals (gcid2+"") && pairs[i].globalcloneid2.equals (gcid1+"")))
            {
                makes = 1;
                break;
            }
        }
        
        return makes;
    }
    
    public String [] getClonePairsForClone (int gcid, SingleClonePair [] pairs)
    {
        String [] affectedpairs = new String [5000];
        int j =0;
        
        for (int i =0;pairs[i] != null;i++)
        {
            if (pairs[i].globalcloneid1.equals (gcid+"") || pairs[i].globalcloneid2.equals (gcid+""))
            {
                affectedpairs[j] = pairs[i].globalcloneid1+", " + pairs[i].globalcloneid2;
                j++;
            }
        }
        return affectedpairs;
    }
    
    
    public void getLatePropagationClonePairsFromDatabase (int clonetype)
    {
        SingleLatePropagation [] lps = new SingleLatePropagation[100000];
        int lpscount = 0;        
        
        class potentialpair
        {
            int gcid1=0, gcid2=0, divergedafter=0, convergedin=0;
        }
        
        potentialpair [] pairs =  new potentialpair[5000000];
        int count = 0;
        
        DatabaseAccess da = new DatabaseAccess ();
        
        for (int r = 1;r<= cp.revisionCount;r++)
        {
            System.out.println ("working on revision = "+r);
            SingleClonePair [] currentpairs = da.getClonePairs(r, clonetype);
            SingleClonePair [] nextpairs = da.getClonePairs(r+1, clonetype);
            
            //updating potential pairs from the current pairs.
            for (int i=0;pairs[i] != null;i++)
            {
                if (pairs[i].convergedin ==0)
                {
                    if (makePair(pairs[i].gcid1, pairs[i].gcid2, currentpairs) == 1)
                    {
                        pairs[i].convergedin = r;
                        
                        lps[lpscount] = new SingleLatePropagation ();
                        lps[lpscount].globalcloneid1 = pairs[i].gcid1+"";
                        lps[lpscount].globalcloneid2 = pairs[i].gcid2+"";
                        lps[lpscount].divergedafter = pairs[i].divergedafter+"";
                        lps[lpscount].convergedin = pairs[i].convergedin+"";
                        lpscount++;
                    }
                }
            }
            
            //determining whether there are any new potential pairs to be added.
            for (int i =0;currentpairs[i] != null;i++)
            {
                int gcid1 = Integer.parseInt(currentpairs[i].globalcloneid1);
                int gcid2 = Integer.parseInt(currentpairs[i].globalcloneid2);
                if (makePair(gcid1, gcid2, nextpairs) == 0)
                {
                    pairs[count] = new potentialpair ();
                    pairs[count].gcid1 = gcid1;
                    pairs[count].gcid2 = gcid2;
                    pairs[count].divergedafter = r;
                    count++;
                }
            }
            
        }                
        da.insertLatePropagations(lps, clonetype);        
    }
    
    
    public void getLPClonePairs (int cloneType)
    {
        int reappearance = 0;
        DatabaseAccess da = new DatabaseAccess ();
        
        SingleLatePropagation [] lps = new SingleLatePropagation[100000];
        int lpscount = 0;
        
        
        int [][] potentialPairs = new int[50000][4];
        int potentialPairCount = 0;        
        
        
        for (int r =1;r<cp.revisionCount;r++)
        {
            System.out.println ("working on revision = "+r);
            SingleClonePair [] currentpairs = da.getClonePairs(r, cloneType);
            SingleClonePair [] nextpairs = da.getClonePairs(r+1, cloneType);
            
            //checking the convergence of existing potential pairs.
            for (int p=0;p<potentialPairCount;p++)
            {
                if (potentialPairs[p][3] == -1)
                {
                    int pair1 = potentialPairs[p][0];
                    int pair2 = potentialPairs[p][1];    
                    
                    int makesapair = makePair (pair1, pair2, currentpairs);                                        
                    if (makesapair > 0) 
                    {
                        /*int changes1 = cm.getChangesToClone(r-1, pair1, cloneType);
                        int changes2 = cm.getChangesToClone(r-1, pair2, cloneType);

                        if (changes1 == 0 && changes2 == 0)
                        {
                            //this is not a convergence.
                            //This is the error of clone detector.
                            continue;
                        }*/
                                                
                        //got a late propagation clone pair.                        
                        potentialPairs[p][3] = r; //the pair again converged in revision r.
                        
                        lps[lpscount] = new SingleLatePropagation ();
                        lps[lpscount].globalcloneid1 = pair1+"";
                        lps[lpscount].globalcloneid2 = pair2+"";
                        lps[lpscount].divergedafter = potentialPairs[p][2]+"";
                        lps[lpscount].convergedin = potentialPairs[p][3]+"";
                        lpscount++;
                        
                        
                        System.out.println ("pair: "+pair1 + " " + pair2 + "    diverged after revision "+ potentialPairs[p][2]+ "      converged in revision " + potentialPairs[p][3]);                        
                        
                        //I would like to get all the late propagations.
                        potentialPairs[p][0] = -1;
                        potentialPairs[p][1] = -1;
                        potentialPairs[p][2] = -1;
                        potentialPairs[p][3] = -1;
                    }
                }
            }                        
            
            //get the clones changed in the commit on revision r.
            String [] changedclones = da.getData("select globalcloneid from type"+cloneType+"clones where revision = "+r+" and changecount > 0 ", "globalcloneid");
            for (int i=0;changedclones[i] != null;i++)
            {
                int changedclone = Integer.parseInt(changedclones[i].trim());
                
                //get clone pairs involving this clone.
                String [] affectedpairs = getClonePairsForClone(changedclone, currentpairs);
                for (int j =0;affectedpairs[j] != null;j++)
                {
                    int pair1 = Integer.parseInt(affectedpairs[j].split("[,]+")[0].trim());                
                    int pair2 = Integer.parseInt (affectedpairs[j].split("[,]+")[1].trim());
                    if (pair1 == pair2) {continue;}
                    if (pair1 <= 0 || pair2 <= 0) {continue;}
                    
                    //is the pair potential?
                    //The pair is potential (the pair diverged) if they are not clones of each other in the next revision.
                    
                    int makespairnext = makePair(pair1, pair2, nextpairs);
                    //Integer.parseInt(da.getData("select count(*) cnt from type"+cloneType+"clonepairs where revision = "+(r+1)+" and ((globalcloneid1 = "+pair1+" and globalcloneid2 ="+pair2+") or (globalcloneid1 = "+pair2+" and globalcloneid2 = "+pair1+"))", "cnt")[0].trim());                    
                    if (makespairnext > 0) {continue;} //the pair is not potential because they did not diverge.
                    
                    //The control comes here because the pair is potential. Now the question is 'is the pair already considered?'
                    int p =0;
                    for (p =0;p<potentialPairCount;p++)
                    {
                        if ((potentialPairs[p][0] == pair1 && potentialPairs[p][1] == pair2) || (potentialPairs[p][0] == pair2 && potentialPairs[p][1] == pair1))
                        {
                            break;
                        }
                    }
                    if (p == potentialPairCount) //include the potential pair.
                    {
                        potentialPairs[potentialPairCount][0] = pair1;
                        potentialPairs[potentialPairCount][1] = pair2;
                        potentialPairs[potentialPairCount][2] = r; //revision after which they diverge.
                        potentialPairs[potentialPairCount][3] = -1;
                        potentialPairCount++;
                    }
                }                
            }            
        }          
        da.insertLatePropagations(lps, cloneType);
    }        
    
    public LatePropagationClonePair [] getLatePropagationClonePairs (int cloneType)
    {
        int reappearance = 0;
                
        LatePropagationClonePair [] lpcPairs = new LatePropagationClonePair[50000];
        int lpcPairCount = 0;
        
        int [][] potentialPairs = new int[50000][4];
        int potentialPairCount = 0;        
        
        
        for (int r =1;r<cp.revisionCount;r++)
        {
            System.out.println ("working on revision = "+r);
            
            //checking the convergence of existing potential pairs.
            for (int p=0;p<potentialPairCount;p++)
            {
                if (potentialPairs[p][3] == -1)
                {
                    int pair1 = potentialPairs[p][0];
                    int pair2 = potentialPairs[p][1];                    
                    
                    int class1 = cm.getCloneClass(r, pair1, cloneType);
                    int class2 = cm.getCloneClass(r, pair2, cloneType);
                                                           
                    if (class1 == class2 && class1 != -1) 
                    {
                        int changes1 = cm.getChangesToClone(r-1, pair1, cloneType);
                        int changes2 = cm.getChangesToClone(r-1, pair2, cloneType);

                        if (changes1 == 0 && changes2 == 0)
                        {
                            //this is not a convergence.
                            //This is the error of clone detector.
                            continue;
                        }
                                                
                        //got a late propagation clone pair.                        
                        potentialPairs[p][3] = r; //the pair again converged in revision r.
                        
                                                
                        lpcPairs[lpcPairCount] =  new LatePropagationClonePair ();
                        lpcPairs[lpcPairCount].gcid1 = pair1;
                        lpcPairs[lpcPairCount].gcid2 = pair2;
                        lpcPairs[lpcPairCount].divergedAfterRevision = potentialPairs[p][2];
                        lpcPairs[lpcPairCount].convergedInRevision = potentialPairs[p][3];
                        lpcPairCount++;
                        
                        
                        System.out.println ("pair: "+pair1 + " " + pair2 + "    diverged after revision "+ potentialPairs[p][2]+ "      converged in revision " + potentialPairs[p][3]);                        
                        
                        //I would like to get all the late propagations.
                        potentialPairs[p][0] = -1;
                        potentialPairs[p][1] = -1;
                        potentialPairs[p][2] = -1;
                        potentialPairs[p][3] = -1;                                                
                    }
                }
            }                        
            
            //get the clones changed in the commit on revision r.
            String changedClones = cm.getChangedClones(r, cloneType);
            if (changedClones.trim().length() == 0) {continue;}
            
            int length = changedClones.trim().split("[ ]+").length;
            for (int i=0;i<length;i++)
            {
                int changedClone = Integer.parseInt(changedClones.trim().split("[ ]+")[i].trim());
                int changedClass = cm.getCloneClass(r, changedClone, cloneType);                
                if (changedClass == -1) {continue;}
                
                String allClones = cm.getClonesFromClass(r, changedClass, cloneType);
                
                int l = allClones.trim().split("[ ]+").length;                
                for (int j =0;j<l;j++)
                {
                    int pair1 = changedClone;                
                    int pair2 = Integer.parseInt (allClones.trim().split("[ ]+")[j]);
                    if (pair1 == pair2) {continue;}
                    
                    
                    //is the pair potential?
                    //The pair is potential (the pair diverged) if they are not clones of each other in the next revision.
                    int nextClass1 = cm.getCloneClass(r+1, pair1, cloneType); 
                    int nextClass2 = cm.getCloneClass(r+1, pair2, cloneType);                     
                    if (nextClass1 == nextClass2) {continue;} //the pair is not potential because they did not diverge.
                    
                    
                    //do the clones in the potential pair have common portions?
                    
                    /*
                    int sline1 = cm.getCloneStartingLine(pair1, r, cloneType);
                    int eline1 = cm.getCloneStartingLine(pair1, r, cloneType);
                    int sline2 = cm.getCloneStartingLine(pair2, r, cloneType);
                    int eline2 = cm.getCloneStartingLine(pair2, r, cloneType);
                    
                    if ((sline1 >= sline2 && sline1<= eline2) || (sline2 >= sline1 && sline2 <= eline1))
                    {
                        //these clones have common parts. So, this pair should not be considered.
                        continue;
                    }*/
                    
                    //is the pair already considered?
                    int p =0;
                    for (p =0;p<potentialPairCount;p++)
                    {
                        if ((potentialPairs[p][0] == pair1 && potentialPairs[p][1] == pair2) || (potentialPairs[p][0] == pair2 && potentialPairs[p][1] == pair1))
                        {
                            break;
                        }
                    }
                    if (p == potentialPairCount) //include the potential pair.
                    {
                        potentialPairs[potentialPairCount][0] = pair1;
                        potentialPairs[potentialPairCount][1] = pair2;
                        potentialPairs[potentialPairCount][2] = r; //revision after which they diverge.
                        potentialPairs[potentialPairCount][3] = -1;
                        potentialPairCount++;
                    }
                }                
            }            
        }
                
        writeLatePropagationClonePairs (cloneType, lpcPairs);
        //DatabaseAccess da = new DatabaseAccess ();
        //da.insertLatePropagations(lps, cloneType);
        
        return lpcPairs;
    }
    
    
    
    public void storeLatePropagation (int clonetype, LatePropagationClonePair [] lpcPairs)
    {
        SingleLatePropagation [] lps = new SingleLatePropagation [100000];
        for (int i =0; lpcPairs[i] != null;i++)
        {
            lps[i] =  new SingleLatePropagation ();
            lps[i].clonetype = clonetype;
            lps[i].globalcloneid1 = lpcPairs[i].gcid1+"";
            lps[i].globalcloneid2 = lpcPairs[i].gcid2+"";
            lps[i].divergedafter = lpcPairs[i].divergedAfterRevision+"";
            lps[i].convergedin = lpcPairs[i].convergedInRevision+"";
        }
        DatabaseAccess da = new DatabaseAccess ();
        da.insertLatePropagations(lps, clonetype);
    }
    
    
    public void writeLatePropagationClonePairs (int cloneType, LatePropagationClonePair [] lpcPairs)
    {
        //writing the late propagation clones.
        try
        {
            BufferedWriter br = new BufferedWriter (new FileWriter (cp.subject_system+"/latepropagations/type"+cloneType+"latepropagations.txt"));
            
            for (int i =0; lpcPairs[i] != null;i++)
            {
                br.write("\n"+lpcPairs[i].gcid1 + " " + lpcPairs[i].gcid2 + " "+lpcPairs[i].divergedAfterRevision + " " + lpcPairs[i].convergedInRevision + " " + lpcPairs[i].isAcceptable );
            }
            
            br.close();
        }
        catch (Exception e)
        {
            System.out.println ("error in method  = writeLatePropagationClonePairs . "+e);
        }        
    }
    
    public LatePropagationClonePair [] readLatePropagationClonePairs (int cloneType)
    {
        LatePropagationClonePair [] lpcPairs = new LatePropagationClonePair[500000];
        int lpcPairCount = 0;
        try
        {
            BufferedReader br = new BufferedReader (new InputStreamReader (new FileInputStream (cp.subject_system+"/latepropagations/type"+cloneType+"latepropagations.txt")));
            String str = "";
            
            while ((str = br.readLine())!= null)
            {
                if (str.trim().length() == 0) {continue;}
                int c1 = Integer.parseInt(str.trim().split("[ ]+")[0].trim());
                int c2 = Integer.parseInt(str.trim().split("[ ]+")[1].trim());
                int da = Integer.parseInt(str.trim().split("[ ]+")[2].trim());
                int ci = Integer.parseInt(str.trim().split("[ ]+")[3].trim());
                int ia = Integer.parseInt(str.trim().split("[ ]+")[4].trim());
                
                lpcPairs[lpcPairCount] = new LatePropagationClonePair ();
                lpcPairs[lpcPairCount].gcid1 = c1;
                lpcPairs[lpcPairCount].gcid2 = c2;
                lpcPairs[lpcPairCount].divergedAfterRevision = da;
                lpcPairs[lpcPairCount].convergedInRevision = ci;
                lpcPairs[lpcPairCount].isAcceptable = ia;
                lpcPairCount++;
            }
            br.close();
        }
        catch (Exception e)
        {
            System.out.println ("error in method = LatePropagationClonePair. "+e);
        }  
        
        return lpcPairs;
    }
    
    public String getLatePropagationClones (int cloneType)
    {        
        //reading the late propagation pairs.        
        LatePropagationClonePair [] lpcPairs = readLatePropagationClonePairs (cloneType);
        String lastRevisionClones = " "+cm.getClonesInRevision(cp.revisionCount, cloneType)+" ";
        String lpClones = "";
        
        
        int i =0;
        while (lpcPairs[i] != null)
        {
            //System.out.println ("checking late propagation = "+(i+1));
            
            //is the pair acceptable.
            if (cloneType == 3)
            {
                if (lpcPairs[i].isAcceptable == 0)
                {
                    i++;
                    continue;
                }                
            }
            
            //is the pair present in the last revision?
            int cls1 = cm.getCloneClass(cp.revisionCount, lpcPairs[i].gcid1, cloneType);
            int cls2 = cm.getCloneClass(cp.revisionCount, lpcPairs[i].gcid2, cloneType);
            
            if (cls1 != cls2) {i++; continue;}
            
            if (!lpClones.contains(" "+lpcPairs[i].gcid1+" ") && lastRevisionClones.contains(" "+lpcPairs[i].gcid1+" "))
            {
                lpClones += " " + lpcPairs[i].gcid1 + " ";
            }
            if (!lpClones.contains(" "+lpcPairs[i].gcid2+" ") && lastRevisionClones.contains(" "+lpcPairs[i].gcid2+" "))
            {
                lpClones += " " + lpcPairs[i].gcid2 + " ";
            }            
            i++;
        }
        
        System.out.println ("Late Propagation Clones: "+lpClones);
        
        return lpClones ;
    }
    
    
    public void analyzeLatePropagations (int cloneType)
    {
        int changedInMatchedCount = 0;
        int changedInNonMatchedCount = 0;
        
        LatePropagationClonePair [] lpcPairs = readLatePropagationClonePairs (cloneType);
        int i =0;
        
        while (lpcPairs[i] != null)
        {            
            if (lpcPairs[i].isAcceptable == 1)
            {
                changedInMatchedCount++;
            }
            else
            {
                changedInNonMatchedCount++;
            }            
            i++;
        }
                  
        System.out.println ("total count = "+i);
        System.out.println ("Late Propagation because of changes in matched portion = "+changedInMatchedCount);
        System.out.println ("Late Propagation because of changes in non-matched portion only = "+changedInNonMatchedCount);        
    }
    
    
    
    public void updateLatePropagationClonePairs (int cloneType)
    {
        LatePropagationClonePair [] lpcPairs = readLatePropagationClonePairs(cloneType);
        int i =0;
        while (lpcPairs[i] != null)
        {
            System.out.println ("checking "+(i+1)+"th late propagation.");
            
            if (isLatePropagationAcceptable(lpcPairs[i].gcid1, lpcPairs[i].gcid2, lpcPairs[i].divergedAfterRevision, lpcPairs[i].convergedInRevision, cloneType))
            {
                lpcPairs[i].isAcceptable = 1;
            }
            else
            {
                lpcPairs[i].isAcceptable = 0;
            }
            i++;
        }
        
        writeLatePropagationClonePairs(cloneType, lpcPairs);
        
    }
    
    
    public boolean isLatePropagationAcceptable (int gcid1, int gcid2, int divergedAfter, int convergedIn, int cloneType)
    {
        int i =0;
        for (i = divergedAfter; i<convergedIn; i++)
        {
            if (changedInMatchedPortion(gcid1, gcid2, i, cloneType))
            {
                return true;
            }
        }
        return false;
    }
    
    public boolean changedInMatchedPortion (int gcid1, int gcid2, int changedIn, int cloneType)
    {                
        String filepath1 = "file1.txt";
        String filepath2 = "file2.txt";
        String filepath3 = "file3.txt";
        String filepath4 = "file4.txt";
        
        String missmatched1 = "", missmatched2 = "";
        String matched1 = "", matched2 = "";

        
        //writing the clones.
        cm.writeClone (gcid1, changedIn, cloneType, filepath1);
        cm.writeClone (gcid2, changedIn, cloneType, filepath2);        
        cm.writeClone (gcid1, changedIn+1, cloneType, filepath3);
        cm.writeClone (gcid2, changedIn+1, cloneType, filepath4);
        
                
        //comparing the two instances of a clone fragment to determine where the changes happened.
        
        //comparing the instances of the first clone fragment.
        String [][] compare1 = cm.compareFiles (filepath1, filepath3);
        String [] changes1 = getChanges (compare1);
        
        //comparing the instances of the second clone fragment.
        String [][] compare2 = cm.compareFiles (filepath2, filepath4);
        String [] changes2 = getChanges (compare2);
        
        
        int i =0;                
        
        cm.applyBlindRenamingToFile(filepath1);
        cm.applyBlindRenamingToFile(filepath2);
        
        
        //comparing the clones to determine the miss-matched lines in the clones.
        String [][] compare = cm.compareFiles(filepath1, filepath2);
        
        for (i =0; compare[i][0] != null;i++)
        {
            if (compare[i][0].trim().length() > 0 && compare[i][2].trim().length() > 0)
            {
                matched1 += " "+compare[i][0] + " ";
                matched2 += " "+compare[i][2] + " ";
            }
        }
        
        String changeLocation1 = changesInMatchedOrMissMatched(changes1, matched1);
        String changeLocation2 = changesInMatchedOrMissMatched(changes2, matched2);
        
        System.out.println ("change location 1 = "+changeLocation1);
        System.out.println ("change location 2 = "+changeLocation2);
        
        int changedInMatchedPortion = 0;
        int changedInNonMatchedPortion = 0;
        
        if (Integer.parseInt(changeLocation1.split("[ ]+")[0].trim()) > 0 || Integer.parseInt(changeLocation2.split("[ ]+")[0].trim()) > 0)
        {
            changedInMatchedPortion = 1;
        }
        if (Integer.parseInt(changeLocation1.split("[ ]+")[1].trim()) > 0 || Integer.parseInt(changeLocation2.split("[ ]+")[1].trim()) > 0)
        {
            changedInNonMatchedPortion = 1;
        }
        if (changedInMatchedPortion > 0) {return true;}
        return false;
    }
    
    
    
    public String analyzeDivergence (int gcid1, int gcid2, int divergedAfter, int cloneType)
    {                
        String filepath1 = "file1.txt";
        String filepath2 = "file2.txt";
        String filepath3 = "file3.txt";
        String filepath4 = "file4.txt";
        
        String missmatched1 = "", missmatched2 = "";
        String matched1 = "", matched2 = "";

        
        //writing the clones.
        cm.writeClone (gcid1, divergedAfter, cloneType, filepath1);
        cm.writeClone (gcid2, divergedAfter, cloneType, filepath2);        
        cm.writeClone (gcid1, divergedAfter+1, cloneType, filepath3);
        cm.writeClone (gcid2, divergedAfter+1, cloneType, filepath4);
        
                
        //comparing the two instances of a clone fragment to determine where the changes happened.
        
        //comparing the instances of the first clone fragment.
        String [][] compare1 = cm.compareFiles (filepath1, filepath3);
        String [] changes1 = getChanges (compare1);
        
        //comparing the instances of the second clone fragment.
        String [][] compare2 = cm.compareFiles (filepath2, filepath4);
        String [] changes2 = getChanges (compare2);
        
        
        int i =0;                
        
        cm.applyBlindRenamingToFile(filepath1);
        cm.applyBlindRenamingToFile(filepath2);
        
        
        //comparing the clones to determine the miss-matched lines in the clones.
        String [][] compare = cm.compareFiles(filepath1, filepath2);
        
        for (i =0; compare[i][0] != null;i++)
        {
            if (compare[i][0].trim().length() > 0 && compare[i][2].trim().length() > 0)
            {
                matched1 += " "+compare[i][0] + " ";
                matched2 += " "+compare[i][2] + " ";
            }
        }
        
        String changeLocation1 = changesInMatchedOrMissMatched(changes1, matched1);
        String changeLocation2 = changesInMatchedOrMissMatched(changes2, matched2);
        
        System.out.println ("change location 1 = "+changeLocation1);
        System.out.println ("change location 2 = "+changeLocation2);
        
        int changedInMatchedPortion = 0;
        int changedInNonMatchedPortion = 0;
        
        if (Integer.parseInt(changeLocation1.split("[ ]+")[0].trim()) > 0 || Integer.parseInt(changeLocation2.split("[ ]+")[0].trim()) > 0)
        {
            changedInMatchedPortion = 1;
        }
        if (Integer.parseInt(changeLocation1.split("[ ]+")[1].trim()) > 0 || Integer.parseInt(changeLocation2.split("[ ]+")[1].trim()) > 0)
        {
            changedInNonMatchedPortion = 1;
        }
        
        return ""+changedInMatchedPortion + " " + changedInNonMatchedPortion;
    }
    
    public String changesInMatchedOrMissMatched (String [] changes1, String matched1)
    {
        int i=0;
        int changesInMatched = 0;
        int changesInMissMatched = 0;
        
        while (changes1[i] != null)
        {
            String lineno = "";
            
            if (changes1[i].contains ("deletion") || changes1[i].contains ("change"))
            {
                int l = changes1[i].trim().split("[ ]+").length;
                lineno = changes1[i].trim().split("[ ]+")[l-1].trim();
                
                if (matched1.contains (" "+lineno+" "))
                {
                    changesInMatched++;
                }
                else
                {
                    changesInMissMatched++;
                }
            }

            if (changes1[i].contains ("addition"))
            {
                int l = changes1[i].trim().split("[ ]+").length;
                lineno = changes1[i].trim().split("[ ]+")[l-1].trim();
                int ln = Integer.parseInt (lineno)+1;
                String nextlineno = ln+"";
                
                if (matched1.contains (" " + nextlineno+" ") && matched1.contains (""+lineno+""))
                {
                    changesInMatched++;                    
                }
                else
                {
                    changesInMissMatched++;
                }                
            }                        
            i++;
        }
        
        return ""+changesInMatched+" "+changesInMissMatched;
    }
    
    public String [] getChanges (String [][] compare1)    
    {
        String [] changes1 = new String [5000];
        int count = 0, i=0;
        
        //determining where the changes occurred.        
        for (i=0; compare1[i][0] != null; i++)
        {
            //in case of addition.
            if (compare1[i][0].trim().length() == 0 && compare1[i][2].trim().length() > 0)
            {
                //determining the line after which the addition was done.
                int j = 0;
                for (j=i;j>=0;j--)
                {
                    if (compare1[j][0].trim().length() > 0)
                    {
                        //if (!changes1[count-1].equals("addition after "+compare1[j][0].trim()))
                        //{
                            changes1[count] = "addition after "+compare1[j][0].trim();
                            count++;                            
                        //}
                        break;
                    }
                }
                if (j == -1)
                {
                    //if (!changes1[count-1].equals("addition after -1"))
                    //{
                        changes1[count] = "addition after -1";
                        count++;                            
                    //}                    
                }
            }
            
            //in case of deletion.
            if (compare1[i][0].trim().length() > 0 && compare1[i][2].trim().length() == 0)
            {
                changes1[count] = "deletion "+ compare1[i][0].trim();
                count++;
            }
            
            //in case of changes.
            if (compare1[i][0].trim().length() > 0 && compare1[i][2].trim().length() > 0)
            {
                if (!compare1[i][1].equals(compare1[i][3]))
                {
                    changes1[count] = "change "+ compare1[i][0].trim();
                    count++;
                }
            }
        }
        
        return changes1;        
    }
    
    public void analyzeEvolutionaryCouplingToMinimizeLatePropagation (int cloneType)
    {
        LatePropagationClonePair [] lpcPairs = readLatePropagationClonePairs (cloneType);
        int minimizeCount = 0;
        int totalCount = 0;
        
        int i =0;
        for (i =0;lpcPairs[i] != null;i++)
        {
            if (cloneType == 3)
            {
                //we should not consider a type 3 late propagation that did not occur 
                //because of changes in the matched portions.
                if (lpcPairs[i].isAcceptable == 0)
                {
                    continue;
                }
            }
            
            
            int c1 = lpcPairs[i].gcid1;
            int c2 = lpcPairs[i].gcid2;
            int divergedAfter = lpcPairs[i].divergedAfterRevision;
            int convergedIn = lpcPairs[i].convergedInRevision;
            int canMinimizeLP = 0;
            
            //we only consider the LP1 to LP5 of Barbour et al.'s paper.
            if (!checkLatePropagationType(c1, c2, divergedAfter, convergedIn, cloneType)) 
            {
                continue;
            }
            
            totalCount++;

            int j =0;
            for (j = divergedAfter-1;j>=1;j--)
            {
                //int cls1 = cm.getCloneClass(j, c1, cloneType);
                //int cls2 = cm.getCloneClass(j, c2, cloneType);

                int changes1 = cm.getChangesToClone(j, c1, cloneType);
                int changes2 = cm.getChangesToClone(j, c2, cloneType);

                //if (cls1 == cls2 && cls1 > -1 && changes1 > 0 && changes2 > 0)
                if (changes1 > 0 && changes2 > 0)
                {
                    canMinimizeLP = 1;
                    break;
                }
            }
            if (canMinimizeLP == 1)
            {
                minimizeCount++;
            }
        }
        
        System.out.println ("total count of late propagations = "+totalCount);
        System.out.println ("We could minimize late propagations = "+minimizeCount);
    }
    
    public boolean checkLatePropagationType (int gcid1, int gcid2, int divergedAfter, int convergedIn, int cloneType)
    {
        int changeInDivergence1 = 0, changeInDivergence2 = 0;
        int changeBeforeConvergence1 = 0, changeBeforeConvergence2 = 0;
        
        changeInDivergence1 = cm.getChangesToClone(divergedAfter, gcid1, cloneType);
        changeInDivergence2 = cm.getChangesToClone(divergedAfter, gcid2, cloneType);
        
        
        //we should not consider those cases where
        //one of the two fragments changed. or
        //both of the fragments changed.
        if (changeInDivergence1 == 0 && changeInDivergence2 == 0) {return false;}
        if (changeInDivergence1 > 0 && changeInDivergence2 > 0) {return false;}
        
        for (int i = divergedAfter+1;i<convergedIn;i++)
        {
            changeBeforeConvergence1 += cm.getChangesToClone(i, gcid1, cloneType);
            changeBeforeConvergence2 += cm.getChangesToClone(i, gcid2, cloneType);
        }
        
        if (changeInDivergence1 > 0) //fragment1 changed at divergence, fragment2 did not.
        {
            if (changeBeforeConvergence2 > 0) {return true;}
        } 
        if (changeInDivergence2 > 0) //fragment2 changed at divergence, fragment1 did not.
        {
            if (changeBeforeConvergence1 > 0) {return true;}
        } 
        
        return false;
    }
    
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(LatePropagation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(LatePropagation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(LatePropagation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(LatePropagation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new LatePropagation().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton11;
    private javax.swing.JButton jButton16;
    private javax.swing.JButton jButton19;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton22;
    private javax.swing.JButton jButton25;
    private javax.swing.JButton jButton28;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton31;
    private javax.swing.JButton jButton4;
    private javax.swing.JButton jButton6;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    private javax.swing.JTextField jTextField1;
    // End of variables declaration//GEN-END:variables
}
