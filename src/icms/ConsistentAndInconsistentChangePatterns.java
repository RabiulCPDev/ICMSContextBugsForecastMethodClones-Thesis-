/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package icms;

import java.io.File;
import javax.swing.JOptionPane;

/**
 *
 * @author Manishankar
 */
public class ConsistentAndInconsistentChangePatterns extends javax.swing.JFrame {

    
    CommonParameters cp = new CommonParameters ();
    DatabaseAccess da = new DatabaseAccess ();
    InvestigatingBugproneness ib = new InvestigatingBugproneness ();
    ChangeAnalysis ca = new ChangeAnalysis ();
    VisualizeCode vc = new VisualizeCode ();
    
    
    
    float discThreshold = 49.9999f;
    
    /**
     * Creates new form ConsistentAndInconsistentChangePatterns
     */
    public ConsistentAndInconsistentChangePatterns() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton1.setText("jButton1");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(120, 120, 120)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 284, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(144, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(142, 142, 142)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(166, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        
        int cloneType = Integer.parseInt(JOptionPane.showInputDialog("Clone Type ? "));
        
        analyzeContextBugsInCodeClones (cloneType);
        
        investigateConsistentAndInconsistentChanges (cloneType);
        
        
        //analyzePredictingCochangeCandidates (cloneType);
        
        
    }//GEN-LAST:event_jButton1ActionPerformed

    
    public void analyzeContextBugsInCodeClones (int cloneType)
    {
        String bugFixCommits = ib.getBugFixCommits();
        
        int contextBugFix = 0;
        
        for (int r = 1;r<cp.revisionCount; r++)
        {            
            if (!bugFixCommits.contains (" "+(r+1)+" ")) {continue;}
            System.out.println ("analyzing revision = "+r);
            
            String changedClones = getChangedClones (cloneType, r);
            if (changedClones.trim().length() == 0) {continue;}
            
            int l = changedClones.trim().split("[ ]+").length;
            for (int i =0;i<l;i++)
            {
                int changedClone = Integer.parseInt(changedClones.trim().split("[ ]+")[i].trim());
                String otherClonesInPair = getClonesThatMadePairWithCloneID (Integer.parseInt(changedClone+""), cloneType, r);
                String otherClonesInPairNotChanged = getSet1MinusSet2(otherClonesInPair, changedClones);
                String otherClonesInPairChanged = getSet1MinusSet2 (otherClonesInPair, otherClonesInPairNotChanged);
                
                if (otherClonesInPairNotChanged.trim().length() == 0){continue;}
                int l2 = otherClonesInPairNotChanged.trim().split("[ ]+").length;
                for (int j =0;j<l2;j++)
                {
                    
                    
                    
                    /*int notChangedClone = Integer.parseInt (otherClonesInPairNotChanged.trim().split("[ ]+")[j].trim());                                        
                    int wasChanged = wasChangedBefore(changedClone, cloneType, r);
                    
                    if (wasChanged == 0)
                    {
                        System.out.println (changedClone+"(changed) "+notChangedClone+"(not changed)" + " revision = " + r + " clone type = "+cloneType);
                        contextBugFix++;
                        analyzeClonePair (changedClone, notChangedClone, cloneType, r);
                    }*/
                }
            }                        
        }
        
        System.out.println ("possible count of context bug-fix = "+contextBugFix);
        System.out.println ("spcp = "+spcp);
        System.out.println ("spcp_lp = "+spcp_lp);
        System.out.println ("diverge = "+diverge);
        
    }
    
    public int wasChangedBefore (int gcid, int cloneType, int revision)
    {
        int result = 0;
        
        try
        {
            da.connect ();
            da.executeQuery ("select sum(changecount) cnt from type"+cloneType+"clones where globalcloneid = '"+gcid+"' and revision < "+revision);
            da.result.next ();
            result = Integer.parseInt(da.result.getString ("cnt"));
            da.disconnect ();
        }
        catch (Exception e)
        {
            //
        }
        
        return result;
    }
    
    
    public void analyzePredictingCochangeCandidates (int cloneType)
    {
        for (int r = 1;r<cp.revisionCount;r++)
        {
            System.out.println ("working on revision = "+r);
            
            String changedClones = getChangedClones (cloneType, r);
            if (changedClones.trim().length() == 0) {continue;}
            
            int l = changedClones.trim().split("[ ]+").length;
            for (int i =0;i<l;i++)
            {
                int changedClone = Integer.parseInt(changedClones.trim().split("[ ]+")[i].trim());
                String otherClonesInPair = getClonesThatMadePairWithCloneID (Integer.parseInt(changedClone+""), cloneType, r);
                String otherClonesInPairNotChanged = getSet1MinusSet2(otherClonesInPair, changedClones);
                String otherClonesInPairChanged = getSet1MinusSet2 (otherClonesInPair, otherClonesInPairNotChanged);
                
                //prediction.
                String cochangeCandidates = otherClonesInPair;
                String cochangedCandidates = otherClonesInPairChanged;                
                predictCochangeCandidates (changedClone, cochangeCandidates, cochangedCandidates, cloneType, r);                                
            }
        }
    }
    
    public String predictCochangeCandidates (int changedClone, String cochangeCandidates, String cochangedCandidates, int cloneType, int revision)
    {
        String result = "";
        String predictedCochangeCandidates = "";
        String cochangePossibilities = "";
        
        try
        {
            int l = cochangeCandidates.trim().split("[ ]+").length;
            for (int i =0;i<l;i++)
            {
                
                int cochangeCandidate = Integer.parseInt(cochangeCandidates.trim().split("[ ]+")[i].trim());
                
                float cochangePossibility = cochangePredictionEngine(changedClone, cochangeCandidate, cloneType, revision);
                if (cochangePossibility > 0) 
                { 
                    predictedCochangeCandidates += " "+cochangeCandidate+" "; 
                    cochangePossibilities += " " + cochangePossibility + " " ;
                }
                
                //storing a true co-change.
                int trueCochange = 0;
                if (cochangedCandidates.contains (" " + cochangeCandidate + " ")) { trueCochange = 1; }
                //if (trueCochange == 1)
                //{
                int sameFile = checkFile(changedClone, cochangeCandidate, cloneType, revision);            
                int sameClass = checkClass(changedClone, cochangeCandidate, cloneType, revision); 
                int samePackage = checkPackage(changedClone, cochangeCandidate, cloneType, revision); 
                float discValue = checkDiscSimilarity (changedClone, cochangeCandidate, cloneType, revision);
                //int similarDISC = (discValue > discThreshold)?1:0;                    
                storeCochange (changedClone, cochangeCandidate, cloneType, revision, sameFile, sameClass, samePackage, discValue, trueCochange);
                //}                                
            }
            
            da.connect ();
            da.executeUpdate("insert into clonecochangeprediction (changedclone, allcochangecandidates, allcochangedcandidates, predictedcochangecandidates, cochangepossibilities, clonetype, revision) values ("
                    +"'"+changedClone+"',"
                    + "'"+cochangeCandidates+"',"
                    + "'"+cochangedCandidates+"',"
                    + "'"+predictedCochangeCandidates+"',"
                    + "'"+cochangePossibilities+"',"
                    + "'"+cloneType+"',"
                    + "'"+revision+"')");
            da.disconnect ();                                                                        
        }
        catch (Exception e)
        {
            //
        }
        
        return result;
    }
    
    public float cochangePredictionEngine (int gcid1, int gcid2, int cloneType, int revision)            
    {
        float result = 0.0f;                
        try
        {
            da.connect ();
            da.executeQuery ("select count(*) cnt from clonecochanges where revision < "+revision+" and clonetype = "+cloneType);
            da.result.next ();
            int cochangeCount = Integer.parseInt (da.result.getString("cnt"));
            da.disconnect ();
            
            
            int sameFile = checkFile(gcid1, gcid2, cloneType, revision);            
            int sameClass = checkClass(gcid1, gcid2, cloneType, revision); 
            int samePackage = checkClass(gcid1, gcid2, cloneType, revision); 
            float discValue = checkDiscSimilarity (gcid1, gcid2, cloneType, revision);
            int similarDISC = (discValue > discThreshold)?1:0;
            
            if (cochangeCount == 0) { return 0.0f; }
            
            /*
            float sameFileWeight = 0.25f;
            float sameClassWeight = 0.25f;
            float samePackageWeight = 0.25f;
            float similarDISCWeight = 0.25f;
            */
            
            
            da.connect ();
            da.executeQuery ("select count(*) cnt from clonecochanges where revision < "+revision +" and clonetype = "+cloneType + " and feature_samefile = 1");
            da.result.next ();
            int sameFileCount = Integer.parseInt (da.result.getString("cnt"));
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select count(*) cnt from clonecochanges where revision < "+revision +" and clonetype = "+cloneType + " and feature_sameclass = 1");
            da.result.next ();
            int sameClassCount = Integer.parseInt (da.result.getString("cnt"));
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select count(*) cnt from clonecochanges where revision < "+revision +" and clonetype = "+cloneType + " and feature_samepackage = 1");
            da.result.next ();
            int samePackageCount = Integer.parseInt (da.result.getString("cnt"));
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select count(*) cnt from clonecochanges where revision < "+revision +" and clonetype = "+cloneType + " and feature_disc > 49.99 ");
            da.result.next ();
            int similarDISCCount = Integer.parseInt (da.result.getString("cnt"));
            da.disconnect ();
                        
            
            float sameFilePossibility = (float)sameFileCount/cochangeCount;
            float samePackagePossibility = (float)samePackageCount/cochangeCount;
            float sameClassPossibility = (float)sameClassCount/cochangeCount;
            float similarDISCPossibility = (float)similarDISCCount/cochangeCount;                                                                       
            
            
            float possibility = sameFilePossibility * sameFile
                                +   samePackagePossibility * samePackage
                                +   sameClassPossibility * sameClass
                                +   similarDISCPossibility * similarDISC;
            possibility = possibility * 100/4;
            
            result = possibility;
            
            
        }
        catch (Exception e)
        {
            //
        }
        
        return result;
    }
    
    
    public void storeCochange (int gcid1, int gcid2, int cloneType, int revision, int sameFile, int sameClass, int samePackage, float similarDISC, int trueCochange)
    {
        try
        {
            //storing the co-change.
            da.connect ();
            da.executeQuery ("select count(*) cnt from clonecochanges where globalcloneid1 = "+gcid1 +" and globalcloneid2 = "+gcid2+" and clonetype = "+cloneType + " and revision = "+ revision );
            da.result.next ();
            int r1 = Integer.parseInt(da.result.getString ("cnt"));
            da.disconnect ();

            da.connect ();
            da.executeQuery ("select count(*) cnt from clonecochanges where globalcloneid1 = "+gcid2 +" and globalcloneid2 = "+gcid1+" and clonetype = "+cloneType + " and revision = "+ revision );
            da.result.next ();
            int r2 = Integer.parseInt(da.result.getString ("cnt"));
            da.disconnect ();

            if (r1 == 0 && r2 == 0)
            {
                da.connect ();
                da.executeUpdate ("insert into clonecochanges (globalcloneid1, globalcloneid2, clonetype, revision, feature_samefile, feature_sameclass, feature_samepackage, feature_disc, cochanged) values ("
                        + "'"+gcid1+"', "
                        + "'"+gcid2+"', "
                        + "'"+cloneType+"', "
                        + "'"+revision+"', "
                        + "'"+sameFile+"',"
                        + "'"+sameClass+"',"
                        + "'"+samePackage+"', "
                        + "'"+similarDISC+"',"
                        + "'"+trueCochange+"')");
                da.disconnect ();
            }
        }
        catch (Exception e)
        {
            //
        }
    }            
    
    
    
    
    public void cochangeStorageEngine (int gcid1, int gcid2, int cloneType, int revision, int trueCochange)
    {
        try
        {
            int spc = -1;//checkSimilarityPreservingChange (gcid1, gcid2, cloneType, revision);
            
            
            int sameFile = checkFile(gcid1, gcid2, cloneType, revision);            
            int sameClass = checkClass(gcid1, gcid2, cloneType, revision); 
            int samePackage = checkClass(gcid1, gcid2, cloneType, revision); 
            float discValue = checkDiscSimilarity (gcid1, gcid2, cloneType, revision);
            int similarDISC = (discValue > discThreshold)?1:0;
            int createdTogether = checkCreation (gcid1, gcid2, cloneType, revision);
            int distance = checkDistance (gcid1, gcid2, cloneType, revision);
            
            
            //storing the co-change.
            da.connect ();
            da.executeQuery ("select count(*) cnt from clonecochanges where globalcloneid1 = "+gcid1 +" and globalcloneid2 = "+gcid2+" and clonetype = "+cloneType + " and revision = "+ revision );
            da.result.next ();
            int r1 = Integer.parseInt(da.result.getString ("cnt"));
            da.disconnect ();

            da.connect ();
            da.executeQuery ("select count(*) cnt from clonecochanges where globalcloneid1 = "+gcid2 +" and globalcloneid2 = "+gcid1+" and clonetype = "+cloneType + " and revision = "+ revision );
            da.result.next ();
            int r2 = Integer.parseInt(da.result.getString ("cnt"));
            da.disconnect ();

            if (r1 == 0 && r2 == 0)
            {
                da.connect ();
                da.executeUpdate ("insert into clonecochanges (globalcloneid1, globalcloneid2, clonetype, revision, feature_samefile, feature_sameclass, feature_samepackage, feature_disc, feature_createdtogether, feature_distance, cochanged, similaritypreservingchange) values ("
                        + "'"+gcid1+"', "
                        + "'"+gcid2+"', "
                        + "'"+cloneType+"', "
                        + "'"+revision+"', "
                        + "'"+sameFile+"',"
                        + "'"+sameClass+"',"
                        + "'"+samePackage+"', "
                        + "'"+discValue+"',"
                        + "'"+createdTogether+"',"
                        + "'"+distance+"',"                        
                        + "'"+trueCochange+"',"
                        + "'"+spc+"')");
                da.disconnect ();
            }
            
        }
        catch (Exception e)
        {
            //
        }        
    }
    
    
    
    public void investigateConsistentAndInconsistentChanges (int cloneType)
    {
        //clearing the table.
        da.connect ();
        da.executeUpdate ("delete from clonecochanges where clonetype = "+cloneType);
        da.disconnect ();
        
        
        int consistentlyChangedPairs = 0, inconsistentlyChangedPairs = 0;
        String bugFixCommits = ib.getBugFixCommits();
        String analyzedPairs = "";
        
        for (int r = 1;r<cp.revisionCount;r++)
        {
            System.out.println ("\nrevision = "+r);
            if (bugFixCommits.contains (" "+(r+1)+" ")){System.out.print ("(bug-fix)");}
            System.out.println();
            
            String changedClones = getChangedClones (cloneType, r);
            if (changedClones.trim().length() == 0) {continue;}
            
            int l = changedClones.trim().split("[ ]+").length;
            for (int i =0;i<l;i++)
            {
                String changedClone = changedClones.trim().split("[ ]+")[i].trim();
                String otherClonesInPair = getClonesThatMadePairWithCloneID (Integer.parseInt(changedClone), cloneType, r);
                String otherClonesInPairNotChanged = getSet1MinusSet2(otherClonesInPair, changedClones);
                String otherClonesInPairChanged = getSet1MinusSet2 (otherClonesInPair, otherClonesInPairNotChanged);
                
                if (otherClonesInPairChanged.trim().length()>0)
                {
                    int l1 = otherClonesInPairChanged.trim().split("[ ]+").length;
                    for (int j=0;j<l1;j++)
                    {
                        String otherClone = otherClonesInPairChanged.trim().split("[ ]+")[j].trim();
                                                                                                
                        String pair = " ("+ changedClone+" " + otherClone+") ";
                        if (!analyzedPairs.contains (pair))
                        {
                            cochangeStorageEngine (Integer.parseInt(changedClone), Integer.parseInt(otherClone), cloneType, r, 1);
                            System.out.println ("\n\n"+changedClone+" (changed)"+otherClonesInPairChanged.trim().split("[ ]+")[j].trim()+" (changed)" + ", cloneType = "+cloneType+", revision = "+r);
                            analyzeClonePair (Integer.parseInt(changedClone), Integer.parseInt(otherClonesInPairChanged.trim().split("[ ]+")[j].trim()), cloneType, r);
                            analyzedPairs += " "+pair+" ";
                        }
                    }
                }
                
                if (otherClonesInPairNotChanged.trim().length() > 0)
                {
                    int l1 = otherClonesInPairNotChanged.trim().split("[ ]+").length;
                    for (int j=0;j<l1;j++)
                    {
                        String otherClone = otherClonesInPairNotChanged.trim().split("[ ]+")[j].trim();
                                                                                                
                        String pair = " ("+ changedClone+" " + otherClone+") ";
                        if (!analyzedPairs.contains (pair))
                        {
                            cochangeStorageEngine (Integer.parseInt(changedClone), Integer.parseInt(otherClone), cloneType, r, 0);
                            System.out.println ("\n\n"+changedClone+" (changed)"+otherClonesInPairNotChanged.trim().split("[ ]+")[j].trim()+" (not changed)" + ", cloneType = "+cloneType+", revision = "+r);
                            analyzeClonePair (Integer.parseInt(changedClone), Integer.parseInt(otherClonesInPairNotChanged.trim().split("[ ]+")[j].trim()), cloneType, r);
                            analyzedPairs += " "+pair+" ";
                        }
                    }                    
                }
            }
        }
        
        System.out.println ("spcp = "+spcp);
        System.out.println ("spcp_lp = "+spcp_lp);
        System.out.println ("diverge = "+diverge);
    }
    
    
    
    //---------------------------------------------------checking features---------------------------------------------------------------------------------
    public int checkFile (int gcid1, int gcid2, int cloneType, int revision)
    {
        int result = 0;        
        try
        {
            da.connect ();
            da.executeQuery ("select filepath from type"+cloneType+"clones where globalcloneid = "+gcid1+" and revision = "+revision);
            da.result.next ();
            String filePath1 = da.result.getString ("filepath");
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select filepath from type"+cloneType+"clones where globalcloneid = "+gcid2+" and revision = "+revision);
            da.result.next ();
            String filePath2 = da.result.getString ("filepath");
            da.disconnect ();
            
            if (filePath1.equals (filePath2)) { result = 1; }            
        }
        catch (Exception e)
        {
            //do nothing.
        }                
        return result;
    }
    
    public int checkClass (int gcid1, int gcid2, int cloneType, int revision)
    {
        int result = 0;
        
        try
        {
            da.connect ();
            da.executeQuery ("select methodid from type"+cloneType+"clones where globalcloneid = "+gcid1+" and revision = "+revision);
            da.result.next ();
            String method1 = da.result.getString ("methodid");            
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select classname from methods where methodid = "+method1+" and revision = "+revision);
            da.result.next ();
            String classname1 = da.result.getString ("classname");
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select methodid from type"+cloneType+"clones where globalcloneid = "+gcid2+" and revision = "+revision);
            da.result.next ();
            String method2 = da.result.getString ("methodid");            
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select classname from methods where methodid = "+method2+" and revision = "+revision);
            da.result.next ();
            String classname2 = da.result.getString ("classname");
            da.disconnect ();            
            
            if (classname1.equals (classname2) && !classname1.equals("null") && classname1.trim().length() > 0) { result = 1; }
        }
        catch (Exception e)
        {
            //
        }
        
        return result;
    }

    public int checkPackage (int gcid1, int gcid2, int cloneType, int revision)
    {
        int result = 0;
        
        try
        {
            da.connect ();
            da.executeQuery ("select methodid from type"+cloneType+"clones where globalcloneid = "+gcid1+" and revision = "+revision);
            da.result.next ();
            String method1 = da.result.getString ("methodid");            
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select packagename from methods where methodid = "+method1+" and revision = "+revision);
            da.result.next ();
            String packagename1 = da.result.getString ("packagename");
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select methodid from type"+cloneType+"clones where globalcloneid = "+gcid2+" and revision = "+revision);
            da.result.next ();
            String method2 = da.result.getString ("methodid");            
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select packagename from methods where methodid = "+method2+" and revision = "+revision);
            da.result.next ();
            String packagename2 = da.result.getString ("packagename");
            da.disconnect ();            
            
            if (packagename1.equals (packagename2) && !packagename1.equals ("null") && packagename1.trim().length() > 0) { result = 1; }            
        }
        catch (Exception e)
        {
            //do nothing.
        }
        
        return result;
    }
    
    public float checkDiscSimilarity (int gcid1, int gcid2, int cloneType, int revision)
    {
        float result = 0.0f;
        
        CodeFragment cf1 = getCodeFragment (gcid1, cloneType, revision);
        CodeFragment cf2 = getCodeFragment (gcid2, cloneType, revision);
        cf1.getFragment();
        cf2.getFragment();
        
        String str1 = "", str2 = "";
        
        for (int i =0;cf1.lines[i] != null;i++)
        {
            str1 += " " + cf1.lines[i];
        }
        for (int i =0;cf2.lines[i] != null;i++)
        {
            str2 += " " + cf2.lines[i];
        }
        
        double match = cp.getStrikeAMatch (str1, str2);
        result = (float)match;
        
        return result;
    }
    
    public int checkCreation (int gcid1, int gcid2, int cloneType, int revision)
    {
        int result = 0;
        
        try
        {
            da.connect ();
            da.executeQuery ("select min(revision) mr from type"+cloneType+"clones where globalcloneid = '"+gcid1+"'");
            da.result.next ();
            int mr = Integer.parseInt (da.result.getString ("mr"));
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select min(revision) mr from type"+cloneType+"clones where globalcloneid = '"+gcid2+"'");
            da.result.next ();
            int mr2 = Integer.parseInt (da.result.getString ("mr"));
            da.disconnect ();
            
            if (mr == mr2) { result = 1; }
        }
        catch (Exception e)
        {
            //
        }
        
        return result;
    }
    
    public int checkDistance (int gcid1, int gcid2, int cloneType, int revision)
    {
        int result = 999999;
        
        try
        {
            da.connect ();
            da.executeQuery ("select filepath, startline, endline from type"+cloneType+"clones where globalcloneid = '"+gcid1+"' and revision = '"+revision+"'");
            da.result.next ();
            String file1 = da.result.getString ("filepath");
            int sline1 = Integer.parseInt(da.result.getString("startline"));
            int eline1 = Integer.parseInt(da.result.getString("endline"));
            da.disconnect ();
            
            da.connect ();
            da.executeQuery ("select filepath, startline, endline from type"+cloneType+"clones where globalcloneid = '"+gcid2+"' and revision = '"+revision+"'");
            da.result.next ();
            String file2 = da.result.getString ("filepath");
            int sline2 = Integer.parseInt(da.result.getString("startline"));
            int eline2 = Integer.parseInt(da.result.getString("endline"));
            da.disconnect ();                        
            
            if (file1.equals (file2))
            {
                if (sline1 < sline2){ result = sline2-eline1; }
                if (sline2 < sline1) { result = sline1 - eline2; }
            }
        }
        catch (Exception e)
        {
            //
        }
        
        return result;
    }
    
    public int checkSimilarityPreservingChange (int gcid1, int gcid2, int cloneType, int revision)
    {
        int result = 0;
        
        CodeFragment cf1 = getCodeFragment(gcid1, cloneType, revision);
        CodeFragment ncf1 = getInstanceInNextRevision(cf1);
        
        
        CodeFragment cf2 = getCodeFragment(gcid2, cloneType, revision);
        CodeFragment ncf2 = getInstanceInNextRevision(cf2);        
        
        
        
        
        for (int clonetype =3;clonetype>=1;clonetype--)
        {        
            System.out.println ("clone type = "+clonetype);
            int ngcid1 = isCloneFragment(ncf1, clonetype);
            int ngcid2 = isCloneFragment(ncf2, clonetype);

            if (ngcid1 > -1 && ngcid2 > -1)
            {
                int isPair = isClonePair(ngcid1, ngcid2, ncf2.revision, clonetype);
                if (isPair == 1) 
                { 
                    result = 1; 
                    System.out.println (gcid1 + " " + gcid2 + " of Type "+clonetype+" experienced similarity preserving change in revision "+revision);
                    break;
                }
            }                
            if (result == 0)
            {
                System.out.println (gcid1 + " " + gcid2 + " of Type "+clonetype+" did not experience similarity preserving change in revision "+revision);
                if (ncf1 == null) { System.out.println("\t"+gcid1+" was deleted."); }
                if (ncf2 == null) { System.out.println("\t"+gcid2+" was deleted."); }
                System.out.println("\t"+"next instance of "+gcid1+" is "+ngcid1 + "("+ncf1.filepath+"," + ncf1.startline+"," + ncf1.endline+")");
                System.out.println("\t"+"next instance of "+gcid2+" is "+ngcid2 + "("+ncf2.filepath+"," + ncf2.startline+"," + ncf2.endline+")");
                if (ngcid1 > -1 && ngcid2 > -1) {System.out.println ("\t"+ngcid1+" and "+ngcid2+" did not make a clone pair.");}            
            }
        }
        
        return result;
    }
    
    
    
    //---------------------------------------------------checking features--------------------------------------------------------------------------------
    
    public int isClonePair (int gcid1, int gcid2, int revision, int cloneType)
    {
        int result = 0;
        try
        {
            da.connect ();
            da.executeQuery("select count(*) cnt from type"+cloneType+"clonepairs where revision = '"+revision+"' and globalcloneid1 = '"+gcid1+"' and globalcloneid2 = '"+gcid2+"' ");
            da.result.next ();
            int c1 = Integer.parseInt (da.result.getString ("cnt"));
            da.disconnect ();
            
            da.connect ();
            da.executeQuery("select count(*) cnt from type"+cloneType+"clonepairs where revision = '"+revision+"' and globalcloneid1 = '"+gcid2+"' and globalcloneid2 = '"+gcid1+"' ");
            da.result.next ();
            int c2 = Integer.parseInt (da.result.getString ("cnt"));
            da.disconnect ();
            
            if (c1 > 0 || c2 > 0) {result = 1;}
        }
        catch (Exception e)
        {
            //
        }
        return result;
    }
    
    
    public int isCloneFragment (CodeFragment cf, int cloneType)
    {
        int result = -1;        
        
        try
        {
            da.connect ();
            da.executeQuery ("select count(*) cnt from type"+cloneType+"clones where startline = '"+cf.startline+"' and endline = '"+cf.endline+"' and filepath = '"+cf.filepath+"' and revision = '"+cf.revision+"' ");
            da.result.next ();
            int cnt = Integer.parseInt(da.result.getString ("cnt"));
            da.disconnect ();
            
            if (cnt > 0)
            {
                da.connect ();
                da.executeQuery ("select globalcloneid from type"+cloneType+"clones where startline = '"+cf.startline+"' and endline = '"+cf.endline+"' and filepath = '"+cf.filepath+"' and revision = '"+cf.revision+"' ");
                da.result.next ();
                result = Integer.parseInt(da.result.getString ("globalcloneid"));
                da.disconnect ();                
            }
        }
        catch (Exception e)
        {
            //
        }
        
        return result;
    }
    
    
    public String getChangedClones (int cloneType, int revision)
    {
        String result = "";
        
        try
        {
            da.connect ();
            da.executeQuery ("select globalcloneid from type"+cloneType+"clones where revision = "+revision+" and changecount > 0");
            while (da.result.next ())
            {
                int gcid = Integer.parseInt (da.result.getString("globalcloneid"));
                if (vc.isChanged(gcid, cloneType, revision) == 1)
                {
                    result += " " + da.result.getString("globalcloneid") + " ";
                }
            }
            da.disconnect ();
        }
        catch (Exception e)
        {
            
        }
        
        return result;
    }
    
    public String getClonesThatMadePairWithCloneID (int gcid, int cloneType, int revision)
    {
        String result = "";
        try
        {            
            int gcid1 = 0, gcid2 = 0, toadd = 0;
            
            DatabaseAccess dbase = new DatabaseAccess ();
            dbase.connect();
            dbase.executeQuery ("select globalcloneid1, globalcloneid2 from type"+cloneType+"clonepairs where (globalcloneid1 = "+gcid+" or globalcloneid2 = "+gcid+") and revision = "+revision);
            while (dbase.result.next ())
            {
                gcid1 = Integer.parseInt(dbase.result.getString ("globalcloneid1"));
                gcid2 = Integer.parseInt(dbase.result.getString ("globalcloneid2"));
                if (gcid1 == gcid) { toadd = gcid2; }
                if (gcid2 == gcid) {toadd = gcid1;}
                
                if (!result.contains (" "+toadd+" ")) { result += " " + toadd + " "; }
            }
            dbase.disconnect ();
        }
        catch (Exception e)
        {
            //
        }
        return result;
    }
    
    public String getSet1MinusSet2 (String set1, String set2)
    {
        String result = "", id = "";        
        
        int l1 = set1.trim().split("[ ]+").length;
        for (int i =0;i<l1;i++)
        {
            id = set1.trim().split("[ ]+")[i].trim();
            if (!set2.contains (" "+id+" ")) { result += " " + id + " "; }
        }
        
        return result;
    }  
    
    
    int spcp = 0;
    int spcp_lp = 0;
    int diverge = 0;
    int typeChange = 0;
    
    public void analyzeClonePair (int gcid1, int gcid2, int clonetype, int revision)
    {
        //String bugFixCommits = ib.getBugFixCommits();
        
        CodeFragment cf1 = getCodeFragment (gcid1, clonetype, revision);
        CodeFragment cf2 = getCodeFragment (gcid2, clonetype, revision);
                
        CodeFragment ncf1 = new CodeFragment ();
        CodeFragment ncf2 = new CodeFragment ();
        
        int similarity = 1, latePropagation = 0;
        int pchanged1=-1, pchanged2 = -1, psimilarity = -1;
        while (true)
        {
            ncf1 = getInstanceInNextRevision(cf1);
            ncf2 = getInstanceInNextRevision(cf2);
            
            if (ncf1==null || ncf2 == null) {break;}
            
            int cp3 = 0, cp2 = 0, cp1 = 0;
            cp3 = isClonePair (ncf1, ncf2, 3);
            if (cp3 == 0) 
            { 
                cp2 = isClonePair (ncf1, ncf2, 2);
                if (cp2 == 0)
                {
                    cp1 = isClonePair (ncf1, ncf2, 1);
                    if (cp1 == 1)
                    {
                        similarity = 1;
                        //System.out.print ("1");
                    }
                    else
                    {
                        similarity = 0;
                        latePropagation = 1;
                        //System.out.print ("0");
                    }
                }
                else
                {
                    similarity = 2;
                    //System.out.print ("1");
                }
            }
            else
            {
                similarity = 3;
                //System.out.print ("1");
            }
            
            int changed1 = 0, changed2 = 0, clonePair = 0;
            
            if (ncf1.changed == 1) { changed1 = 1; }
            if (ncf2.changed == 1) { changed2 = 1; }
            if (clonePair == 0) { clonePair = similarity; }
            
            if (changed1 != pchanged1 || changed2 != pchanged2 || psimilarity != similarity)
            {
                System.out.print ("\n\t\t("+changed1+", "+changed2+", "+clonePair+" | revision =  "+ncf1.revision+" | "+ncf1.startline+", "+ncf1.endline+", "+ncf1.filepath+" | "+ncf2.startline+", "+ncf2.endline+", "+ncf2.filepath+")");
            }
            
            pchanged1 = changed1;
            pchanged2 = changed2;
            psimilarity = similarity;
            
            //if (ncf1.changed == 1){ System.out.print (" "+gcid1+" Changed. "); }
            //else { System.out.print (" "+gcid1+" Not Changed. "); }
            
            //if (ncf2.changed == 1){ System.out.print (" "+gcid2+" Changed. "); }
            //else { System.out.print (" "+gcid2+" Not Changed. "); }
            
            
            
            
            cf1 = ncf1;
            cf2 = ncf2;
        }
        
        if (similarity >= 1) 
        {
            try
            {
                da.connect ();
                da.executeUpdate ("update clonecochanges set spcp = 1 where globalcloneid1 = '"+gcid1+"' and globalcloneid2 = '"+gcid2+"' and clonetype = '"+clonetype+"' and revision = '"+revision+"'");
                da.disconnect ();
            }
            catch (Exception e) { }
            
            
            spcp++;
            if (latePropagation == 1) 
            { 
                try
                {
                    da.connect ();
                    da.executeUpdate ("update clonecochanges set spcp = 2 where globalcloneid1 = '"+gcid1+"' and globalcloneid2 = '"+gcid2+"' and clonetype = '"+clonetype+"' and revision = '"+revision+"'");
                    da.disconnect ();
                }
                catch (Exception e) { }
                
                
                spcp_lp++; }
        }
        else 
        { 
            try
            {
                da.connect ();
                da.executeUpdate ("update clonecochanges set spcp = 0 where globalcloneid1 = '"+gcid1+"' and globalcloneid2 = '"+gcid2+"' and clonetype = '"+clonetype+"' and revision = '"+revision+"'");
                da.disconnect ();
            }
            catch (Exception e) { }
            
            diverge++; 
        }
        
    }
    
    public int isClonePair (CodeFragment cf1, CodeFragment cf2, int cloneType)
    {
        int result = 0;
        
        int gcid1 = isCloneFragment(cf1, cloneType);
        int gcid2 = isCloneFragment(cf2, cloneType);
        
        if (gcid1 > 0 && gcid2 > 0)
        {
            result = isClonePair(gcid1, gcid2, cf1.revision, cloneType);
        }
        
        return result;
    }

    public CodeFragment getCodeFragment (int gcid, int clonetype, int revision)
    {
        SingleClone clone = da.getCloneInfo(gcid, clonetype, revision);
        if (clone == null) { return null; }
        
        CodeFragment cf = new CodeFragment ();
        cf.changed = Integer.parseInt(clone.changecount);
        cf.filepath = clone.filepath;
        cf.startline = Integer.parseInt(clone.startline);
        cf.endline = Integer.parseInt(clone.endline);
        cf.revision = revision;
        cf.gcid = gcid;  
        
        return cf;
    }

    public int areDifferentFragments (CodeFragment cf1, CodeFragment cf2)
    {
        try
        {
            cf1.getFragment();
            cf2.getFragment();

            int i =0;
            while (cf1.lines[i] != null || cf2.lines[i] != null)
            {
                if (!cf1.lines[i].trim().equals (cf2.lines[i].trim()) && (cf1.lines[i].trim().length() > 0 || cf2.lines[i].trim().length() > 0))
                {
                    return 1;
                }
                i++;
            }

            return 0;
        }
        catch (Exception e)
        {
            System.out.println ("error occurred. ignored it.");
            return 0;
        }
    }
    
    public CodeFragment getInstanceInPreviousRevision (CodeFragment cf)
    {
        CodeFragment instance = new CodeFragment ();
        
        int crevision = cf.revision;
        int prevision = crevision-1;
        
        int pstartline = 999999999;
        int pendline = -1;
        
        int changed = 0;
        int similarity = 0;
        
        String cfilepath = cp.subject_system + "/repository/version-" + crevision + "/"+ cf.filepath;
        String pfilepath = cp.subject_system + "/repository/version-" + prevision + "/"+ cf.filepath;
        
        File file = new File (pfilepath);
        if (!file.exists()) { return null; }
        
        
        String [][] filecompare = ca.compareFiles(pfilepath, cfilepath);
                
        for (int i =0;filecompare[i][0] != null;i++)
        {
            String ln = filecompare[i][2].trim();
            if (ln.length() == 0) {continue;}
            int line = Integer.parseInt(ln);
            if (line > cf.endline) {break;}
            if (line >= cf.startline && line <= cf.endline)
            {
                String pln = filecompare[i][0].trim();
                if (pln.trim().length() > 0)
                {
                    int pline = Integer.parseInt (pln);
                    if (pstartline > pline){ pstartline = pline; }
                    if (pendline < pline) { pendline = pline; }                
                }
                if (!filecompare[i][1].trim().equals (filecompare[i][3].trim()))
                {
                    if (filecompare[i][1].trim().length() > 0 || filecompare[i][3].trim().length() > 0)
                    {
                        changed = 1;
                    }
                }
                if (filecompare[i][1].trim().equals (filecompare[i][3].trim()))
                {
                    if (filecompare[i][1].trim().length() > 0 )
                    {
                        similarity = 1;
                    }
                }
            }
        }
        
        if (similarity == 0) { return null; }
        
        if (pendline == -1)
        {
            return null;
        }
        
        instance.revision = prevision;
        instance.filepath = cf.filepath;
        instance.startline = pstartline;
        instance.endline = pendline;
        instance.changed = changed;
        instance.gcid = cf.gcid;
        
        return instance;
    }
    
    
    public CodeFragment getInstanceInNextRevision (CodeFragment cf)
    {        
        CodeFragment instance = new CodeFragment ();
        
        int crevision = cf.revision;
        int prevision = crevision+1;
        
        if (prevision > cp.revisionCount) { return null; }
        
        int pstartline = 999999999;
        int pendline = -1;
        
        int changed = 0;
        int similarity = 0;
        
        String cfilepath = cp.subject_system + "/repository/version-" + crevision + "/"+ cf.filepath;
        String pfilepath = cp.subject_system + "/repository/version-" + prevision + "/"+ cf.filepath;
        
        File file = new File (pfilepath);
        if (!file.exists()) { return null; }
        
        
        String [][] filecompare = ca.compareFiles(cfilepath, pfilepath);
                
        for (int i =0;filecompare[i][0] != null;i++)
        {
            String ln = filecompare[i][0].trim();
            if (ln.length() == 0) {continue;}
            int line = Integer.parseInt(ln);
            if (line > cf.endline) {break;}
            if (line >= cf.startline && line <= cf.endline)
            {
                String pln = filecompare[i][2].trim();
                if (pln.trim().length() > 0)
                {
                    int pline = Integer.parseInt (pln);
                    if (pstartline > pline){ pstartline = pline; }
                    if (pendline < pline) { pendline = pline; }                
                }
                if (!filecompare[i][1].trim().equals (filecompare[i][3].trim()))
                {
                    if (filecompare[i][1].trim().length() > 0 || filecompare[i][3].trim().length() > 0)
                    {
                        changed = 1;
                    }
                }
                if (filecompare[i][1].trim().equals (filecompare[i][3].trim()))
                {
                    if (filecompare[i][1].trim().length() > 0 )
                    {
                        similarity = 1;
                    }
                }
            }
        }
        
        if (similarity == 0) { return null; }
        
        if (pendline == -1)
        {
            return null;
        }
        
        instance.revision = prevision;
        instance.filepath = cf.filepath;
        instance.startline = pstartline;
        instance.endline = pendline;
        instance.changed = changed;
        instance.gcid = cf.gcid;
        
        return instance;
    }
    
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ConsistentAndInconsistentChangePatterns.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ConsistentAndInconsistentChangePatterns.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ConsistentAndInconsistentChangePatterns.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ConsistentAndInconsistentChangePatterns.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ConsistentAndInconsistentChangePatterns().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    // End of variables declaration//GEN-END:variables
}
